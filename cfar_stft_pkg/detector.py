"""CFAR-STFT detector (refactored package entry).

This module is generated by splitting `src/cfar_stft_detector.py` into smaller
modules, while keeping the original file intact.

The implementation below mirrors the original classes and functions starting
from `CFARSTFTDetector`.
"""

from __future__ import annotations

import warnings
from typing import Dict, List, Optional, Tuple

import numpy as np
from scipy import ndimage, signal
from scipy.io import wavfile

from .cfar2d import CFAR2D
from .dbscan import DBSCAN
from .fractal import fractal_dimension_higuchi, hurst_exponent
from .types import DetectedComponent
from . import cfar_fit, doppler_ops, mask_ops, reconstruct_ops, stft_ops


class CFARSTFTDetector:
    """
    Detector principal CFAR-STFT pentru extractia componentelor
    
    Implementeaza algoritmul complet din paper:
    "Radar Detection-Inspired Signal Retrieval from the Short-Time Fourier Transform"
    Abratkiewicz, K. (2022). Sensors, 22(16), 5954.
    
    Algoritm:
    1. STFT cu fereastra Gaussiana (Eq. 3)
    2. Detectie GOCA-CFAR 2D adaptiva (Eq. 7)
    3. Clustering DBSCAN (coordonate reale Hz/sec)
    4. Extindere masti cu geodesic dilation catre zerourile spectrogramei
    5. Reconstructie semnal prin STFT inversa
    
    Suporta:
    - Semnale REALE (audio, sintetic) - one-sided spectrum
    - Semnale COMPLEXE (radar I/Q) - two-sided spectrum cu Doppler
    """
    
    def __init__(self,
                 sample_rate: int = 44100,
                 window_size: int = 2048,
                 hop_size: int = 512,
                 cfar_guard_cells: int = 2,
                 cfar_training_cells: int = 4,
                 cfar_pfa: float = 1e-3,
                 dbscan_eps: float = 5.0,
                 dbscan_min_samples: int = 10,
                 use_vectorized_cfar: bool = True,
                 zero_threshold_percentile: float = 5.0,
                 mode: str = 'auto',
                 fractal_mode: str = 'time'):
        """
        Initializare detector
        
        Args:
            sample_rate: Rata de esantionare (Hz) sau PRF pentru radar
            window_size: Dimensiunea ferestrei STFT (samples)
            hop_size: Pasul intre ferestre (samples)
            cfar_guard_cells: Celule de garda CFAR (paper: N_G = 16)
            cfar_training_cells: Celule de antrenament CFAR (paper: N_T = 16)
            cfar_pfa: Probabilitatea de alarma falsa (paper: P_f = 0.4)
            dbscan_eps: Raza DBSCAN (in spatiu normalizat)
            dbscan_min_samples: Puncte minime pentru cluster
            use_vectorized_cfar: Foloseste CFAR vectorizat (mai rapid)
            zero_threshold_percentile: Percentila pentru detectia zerourilor
            mode: 'auto' | 'real' | 'complex' | 'radar'
                  - 'auto': detecteaza automat din tipul datelor
                  - 'real': forteaza procesare semnal real (one-sided)
                  - 'complex': forteaza procesare semnal complex (two-sided)
                  - 'radar': optimizat pentru I/Q radar (two-sided + Doppler)
        """
        self.fs = sample_rate
        self.window_size = window_size
        self.hop_size = hop_size
        self.use_vectorized_cfar = use_vectorized_cfar
        self.zero_threshold_percentile = zero_threshold_percentile
        self.mode = mode
        self._is_complex_input = False  # Set during processing
        # Fractal boost mode:
        # - 'time': Hurst computed on time-domain envelope |x[n]| and projected to TF time bins
        # - 'tf':   Hurst computed from local TF patches (power series) -> M_H(k,n) in TF
        self.fractal_mode = (fractal_mode or 'time').lower().strip()
        
        # Initializam componentele
        self.cfar = CFAR2D(
            guard_cells_v=cfar_guard_cells,
            guard_cells_h=cfar_guard_cells,
            training_cells_v=cfar_training_cells,
            training_cells_h=cfar_training_cells,
            pfa=cfar_pfa,
            distribution='k'  # K-distribution for sea clutter
        )
        
        # DBSCAN cu scale pentru coordonate reale
        # freq_scale=100Hz, time_scale=0.05s inseamna ca eps=1 corespunde
        # la o distanta de ~100Hz sau ~50ms
        self.dbscan = DBSCAN(
            eps=dbscan_eps, 
            min_samples=dbscan_min_samples,
            freq_scale=100.0,
            time_scale=0.05
        )
        
        # Cache pentru rezultate
        self.stft_result = None
        self.detection_map = None
        self.zero_map = None
        self.components = []
    
    def compute_stft(self, signal_data: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        Calculeaza STFT cu fereastra Gaussiana
        
        Ecuatia (3) din paper:
        F_x^h[m,k] = Sum x[n] h[n-m] e^(-j2*pi*k*(n-m)/N)
        
        Pentru semnale COMPLEXE (radar I/Q):
        - Foloseste spectru two-sided (frecvente negative = Doppler negativ)
        - Frecventele sunt centrate la 0 (fftshift)
        
        Pentru semnale REALE (audio):
        - Foloseste spectru one-sided (doar frecvente pozitive)
        
        Returns:
            (stft_complex, frequencies, times)
        """
        return stft_ops.compute_stft(self, signal_data)

    def _ensure_cfar_fits(self, n_freq: int, n_time: int) -> bool:
        """
        Ajusteaza automat dimensiunile CFAR pentru a incapea in grila TF.
        Returneaza False daca nu se poate face detectie CFAR valida.
        """
        return cfar_fit.ensure_cfar_fits(self, n_freq, n_time)
    
    def _expand_mask_geodesic(self, mask: np.ndarray, max_iterations: int = 10) -> np.ndarray:
        """
        Extinde masca folosind geodesic dilation catre zerourile spectrogramei
        
        Aceasta metoda creste masca clusterului pana la barierele definite
        de zerourile spectrogramei, conform ideii din paper.
        
        Args:
            mask: Masca initiala (boolean)
            max_iterations: Numar maxim de iteratii de dilatare
            
        Returns:
            Masca extinsa
        """
        return mask_ops.expand_mask_geodesic(self, mask, max_iterations=max_iterations)
    
    def detect_components(self, signal_data: np.ndarray, 
                         n_components: int = None) -> List[DetectedComponent]:
        """
        Detecteaza si extrage componente din semnal
        
        Pasii algoritmului (conform paper):
        1. Calculeaza STFT
        2. Detecteaza regiuni cu GOCA-CFAR 2D
        3. Grupeaza cu DBSCAN (coordonate normalizate la rezolutia STFT, unitati de bin)
        4. Extinde mastile cu geodesic dilation
        5. Sorteaza dupa energie
        
        Args:
            signal_data: Semnalul de analizat
            n_components: Numarul de componente de extras (None = toate)
            
        Returns:
            Lista componentelor detectate
        """
        # Pasul 1: Calculam STFT
        Zxx, freqs, times = self.compute_stft(signal_data)
        # Paper: CFAR se aplica pe PUTERE |STFT|^2, nu pe magnitudine
        power = self.stft_result['power']
        magnitude = self.stft_result['magnitude']
        
        # Pasul 2: Validam dimensiunile CFAR pentru grila TF
        if not self._ensure_cfar_fits(power.shape[0], power.shape[1]):
            return []

        # Pasul 3: Detectie GOCA-CFAR 2D pe POWER (conform paper)
        print("   [CFAR] Aplicare detectie adaptiva 2D pe power...")
        if self.use_vectorized_cfar:
            self.detection_map = self.cfar.detect_vectorized(power)
        else:
            self.detection_map = self.cfar.detect(power)
        
        n_detected = np.sum(self.detection_map)
        print(f"   [CFAR] Puncte detectate: {n_detected}")
        
        if n_detected == 0:
            return []
        
        # Pasul 4: Clustering DBSCAN in unitati de bin (f/df, t/dt), stabil la schimbarea rezolutiei STFT
        print("   [DBSCAN] Grupare puncte detectate...")
        detected_points = np.array(np.where(self.detection_map)).T  # (N, 2)
        
        # DBSCAN lucreaza pe coordonate normalizate la rezolutia STFT (f/df, t/dt),
        # astfel incat eps ramane stabil la schimbarea rezolutiei (hop/nfft).
        cluster_labels = self.dbscan.fit(detected_points, freqs, times)
        unique_labels = set(cluster_labels) - {-1}  # Excludem zgomotul
        
        print(f"   [DBSCAN] Clustere gasite: {len(unique_labels)}")
        
        # Pasul 5: Cream componente cu masti extinse geodesic
        components = []
        
        for cluster_id in unique_labels:
            cluster_mask = cluster_labels == cluster_id
            cluster_points = detected_points[cluster_mask]
            
            freq_indices = cluster_points[:, 0]
            time_indices = cluster_points[:, 1]
            
            # Calculam energia componentei
            energy = np.sum(magnitude[freq_indices, time_indices] ** 2)
            
            # Centroidul (in valori reale)
            centroid_freq = np.mean(freqs[freq_indices])
            centroid_time = np.mean(times[time_indices])
            
            # Cream masca TF initiala
            mask = np.zeros_like(magnitude, dtype=bool)
            mask[freq_indices, time_indices] = True
            
            # Extindem masca cu geodesic dilation catre zerouri
            mask = self._expand_mask_geodesic(mask)
            
            component = DetectedComponent(
                cluster_id=int(cluster_id),
                time_indices=time_indices,
                freq_indices=freq_indices,
                energy=energy,
                centroid_time=centroid_time,
                centroid_freq=centroid_freq,
                mask=mask
            )
            
            components.append(component)
        
        # Sortam dupa energie (descrescator)
        components.sort(key=lambda x: x.energy, reverse=True)
        
        # Limitam la n_components daca specificat
        if n_components is not None:
            components = components[:n_components]
        
        self.components = components
        
        print(f"   [SORT] Componente sortate dupa energie: {len(components)}")
        
        return components
    
    def detect_with_fractal_boost(self, signal_data: np.ndarray, 
                                  hurst_deviation_threshold: float = 0.15,
                                  window_samples: int = 64,
                                  fractal_mode: Optional[str] = None,
                                  time_window_frames: int = 24,
                                  time_step_frames: int = 12,
                                  freq_band_bins: int = 9,
                                  freq_stride: int = 4) -> Tuple[np.ndarray, Dict]:
        """
        Enhanced detection combining GOCA-CFAR with fractal features.
        
        The Hurst exponent of sea clutter is typically 0.7-0.8.
        Targets disrupt this pattern. This method fuses CFAR detections
        with Hurst anomaly detection for +10-15% Pd improvement.
        
        Reference: Xu (2010) "Low observable targets detection by joint 
        fractal properties of sea clutter" - IEEE TAP, 103 citations
        
        Args:
            signal_data: Complex radar signal (I/Q)
            hurst_deviation_threshold: How much H can deviate from clutter mean
            window_samples: Window size for Hurst computation
            
        Returns:
            (combined_detection_map, stats_dict)
        """
        # Step 1: Standard CFAR detection (GOCA/CA depending on configuration)
        components = self.detect_components(signal_data)
        cfar_map = self.detection_map.copy() if self.detection_map is not None else None
        
        if cfar_map is None:
            return None, {}

        mode_to_use = (fractal_mode or self.fractal_mode or 'time').lower().strip()

        # Build the fractal anomaly mask in TF.
        fractal_boost_map = np.zeros_like(cfar_map, dtype=bool)

        # --- Mode A: time-domain Hurst projected to TF (legacy behavior) ---
        hurst_values = None
        clutter_hurst = None
        if mode_to_use == 'time':
            # Step 2: Compute Hurst exponent along time axis (on |x[n]| envelope)
            print("   [FRACTAL] Computing Hurst exponent for fractal boost (time-domain)...")
            magnitude = np.abs(signal_data)
            n_samples = len(magnitude)
            n_windows = max(1, n_samples // max(1, int(window_samples)))

            hv = []
            for i in range(n_windows):
                w = magnitude[i * window_samples : (i + 1) * window_samples]
                if len(w) < max(16, window_samples // 2):
                    continue
                h = hurst_exponent(w, max_lag=max(8, window_samples // 4))
                hv.append(h)

            hurst_values = np.array(hv, dtype=float)
            clutter_hurst = float(np.median(hurst_values)) if len(hurst_values) else 0.5

            # Step 3: Find Hurst anomalies and map back to spectrogram time axis (vertical time bands).
            hurst_anomaly = np.abs(hurst_values - clutter_hurst) > hurst_deviation_threshold
            times = self.stft_result['times']
            time_per_window = window_samples / self.fs
            for i, is_anomaly in enumerate(hurst_anomaly):
                if not is_anomaly:
                    continue
                t_start = i * time_per_window
                t_end = (i + 1) * time_per_window
                time_mask = (times >= t_start) & (times < t_end)
                fractal_boost_map[:, time_mask] = True

        # --- Mode B: TF-local Hurst (patch-based) ---
        elif mode_to_use == 'tf':
            # Step 2: Compute TF-local Hurst from STFT power patches.
            # For each frequency band, create a time series (mean log-power over band),
            # compute Hurst on sliding windows in time (frames), then project back to TF.
            power = self.stft_result.get('power')
            if power is None:
                return cfar_map, {"note": "Missing STFT power; returned CFAR-only map."}

            n_freq, n_time = power.shape
            tw = int(time_window_frames)
            ts = int(time_step_frames)
            if tw < 8:
                tw = 8
            if ts < 1:
                ts = 1

            if n_time < tw:
                # Too few STFT frames; fallback to legacy time-domain projection.
                return self.detect_with_fractal_boost(
                    signal_data,
                    hurst_deviation_threshold=hurst_deviation_threshold,
                    window_samples=window_samples,
                    fractal_mode='time',
                )

            print("   [FRACTAL] Computing Hurst exponent for fractal boost (TF-local)...")

            logP = np.log(power + 1e-12)
            half_band = max(1, int(freq_band_bins) // 2)

            hurst_records = []  # (k_center, H0, anomaly_rate)

            for k in range(0, n_freq, max(1, int(freq_stride))):
                k0 = max(0, k - half_band)
                k1 = min(n_freq, k + half_band + 1)

                series = np.mean(logP[k0:k1, :], axis=0)  # (n_time,)

                H_vals = []
                windows = []
                for t0 in range(0, n_time - tw + 1, ts):
                    t1 = t0 + tw
                    w = series[t0:t1]
                    h = hurst_exponent(w, max_lag=max(8, tw // 4))
                    H_vals.append(h)
                    windows.append((t0, t1))

                if len(H_vals) < 5:
                    continue

                H_vals = np.array(H_vals, dtype=float)
                H0 = float(np.median(H_vals))
                anomalies = np.abs(H_vals - H0) > hurst_deviation_threshold

                for is_anom, (t0, t1) in zip(anomalies, windows):
                    if is_anom:
                        fractal_boost_map[k0:k1, t0:t1] = True

                hurst_records.append((k, H0, float(np.mean(anomalies))))

        else:
            # Unknown mode: behave like legacy (safe default).
            return self.detect_with_fractal_boost(
                signal_data,
                hurst_deviation_threshold=hurst_deviation_threshold,
                window_samples=window_samples,
                fractal_mode='time',
            )

        # Expose maps for debugging/visualization (e.g., animation overlays).
        self._last_cfar_map = cfar_map
        self._last_fractal_boost_map = fractal_boost_map
        
        # Step 4: Combine: CFAR OR (fractal_anomaly AND high-power gate).
        # For TF-local mode, we also require proximity to CFAR to avoid painting large clutter regions.
        power = self.stft_result['power']
        power_thr = np.percentile(power, 85.0)
        power_mask = power > power_thr

        if mode_to_use == 'tf':
            cfar_neighborhood = ndimage.binary_dilation(cfar_map, iterations=1)
            combined_map = cfar_map | ((fractal_boost_map & power_mask) & cfar_neighborhood)
        else:
            combined_map = cfar_map | (fractal_boost_map & power_mask)
        
        # Stats
        n_cfar_only = np.sum(cfar_map & ~fractal_boost_map)
        n_fractal_boost = np.sum(combined_map & ~cfar_map)
        n_total = np.sum(combined_map)
        
        stats = {
            'fractal_mode': mode_to_use,
            'clutter_hurst': clutter_hurst,
            'hurst_values': hurst_values,
            'n_cfar_detections': np.sum(cfar_map),
            'n_fractal_candidates': int(np.sum(fractal_boost_map)),
            'n_fractal_boosted': n_fractal_boost,
            'n_total_detections': n_total,
            'boost_percentage': 100 * n_fractal_boost / max(1, np.sum(cfar_map))
        }
        
        if clutter_hurst is not None:
            print(f"   [FRACTAL] Clutter Hurst: {clutter_hurst:.3f}")
        print(f"   [FRACTAL] Boosted detections: +{n_fractal_boost} ({stats['boost_percentage']:.1f}%)")
        
        self.detection_map = combined_map
        return combined_map, stats
    
    def reconstruct_component(self, component: DetectedComponent, 
                              use_power_threshold: bool = True,
                              threshold_db: float = -20.0) -> np.ndarray:
        """
        Reconstruieste un semnal din componenta folosind STFT inversa
        
        Pasul 7 din algoritm (Eq. 12-13): Aplicam masca si ISTFT
        
        IMPORTANT: Folosim o masca extinsa bazata pe pragul de putere
        pentru a captura mai multa energie din semnal. Masca binara
        din CFAR/DBSCAN este prea restrictiva si pierde energie.
        
        Args:
            component: Componenta detectata
            use_power_threshold: Daca True, extinde masca folosind prag de putere
                                 Daca False, foloseste masca CFAR/DBSCAN directa
            threshold_db: Pragul in dB sub peak pentru extinderea mastii
                         (implicit -20 dB = include tot ce e > 1% din peak)
        
        Returns:
            Semnalul reconstruit
        """
        return reconstruct_ops.reconstruct_component(
            self,
            component,
            use_power_threshold=use_power_threshold,
            threshold_db=threshold_db,
        )
    
    def get_spectrogram_db(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Returneaza spectrograma in dB"""
        if self.stft_result is None:
            return None, None, None
        
        Sxx_db = 20 * np.log10(self.stft_result['magnitude'] + 1e-10)
        return self.stft_result['freqs'], self.stft_result['times'], Sxx_db
    
    def get_doppler_info(self, component: DetectedComponent) -> Dict:
        """
        Extrage informatii Doppler dintr-o componenta detectata (pentru radar)
        
        Pentru radar cu PRF=fs:
        - Doppler frequency fd = frecventa in spectrograma
        - Viteza radiala v = fd * c / (2 * f_RF)
        
        Args:
            component: Componenta detectata
            
        Returns:
            Dict cu informatii Doppler
        """
        return doppler_ops.get_doppler_info(self, component)
    
    def _doppler_to_velocity(self, fd: float, rf_ghz: float = 9.39) -> float:
        """
        Converteste frecventa Doppler in viteza radiala
        
        v = fd * c / (2 * f_RF)
        
        Args:
            fd: Frecventa Doppler (Hz)
            rf_ghz: Frecventa RF radar (GHz)
            
        Returns:
            Viteza radiala (m/s), pozitiva = se apropie
        """
        return doppler_ops.doppler_to_velocity(fd, rf_ghz=rf_ghz)


class AcousticCFARDetector:
    """
    Detector acustic de avioane bazat pe CFAR-STFT
    
    Combina tehnicile din paper cu semnaturile spectrale ale avioanelor
    pentru detectie si clasificare.
    
    NOTA: Clasificarea este bazata pe reguli (heuristic), nu ML.
    Pentru clasificare ML, ar trebui folosit un model antrenat pe AudioSet.
    """
    
    # Semnaturi spectrale (hardcodate - nu ML)
    AIRCRAFT_SIGNATURES = {
        'jet_engine': {
            'freq_range': (500, 8000),
            'fundamental': 1000,
            'harmonics': [1000, 2000, 4000, 6000],
            'bandwidth': 'broadband',
            'modulation': 'continuous'
        },
        'propeller': {
            'freq_range': (50, 500),
            'fundamental': 80,
            'harmonics': [80, 160, 240, 320, 400],
            'bandwidth': 'narrowband',
            'modulation': 'periodic'
        },
        'helicopter': {
            'freq_range': (20, 200),
            'fundamental': 25,  # Main rotor ~25 Hz
            'harmonics': [25, 50, 75, 100, 125, 150],
            'bandwidth': 'narrowband',
            'modulation': 'periodic'
        },
        'turboprop': {
            'freq_range': (80, 2000),
            'fundamental': 100,
            'harmonics': [100, 200, 300, 400, 500],
            'bandwidth': 'mixed',
            'modulation': 'continuous'
        },
        'drone': {
            'freq_range': (100, 8000),
            'fundamental': 200,
            'harmonics': [200, 400, 600, 800, 1000],
            'bandwidth': 'narrowband',
            'modulation': 'periodic'
        }
    }
    
    def __init__(self, sample_rate: int = 44100):
        self.fs = sample_rate
        self.cfar_detector = CFARSTFTDetector(
            sample_rate=sample_rate,
            window_size=2048,
            hop_size=256,  # Mai multa rezolutie temporala
            cfar_pfa=5e-4,  # Prag mai relaxat pentru audio
            dbscan_eps=8.0,
            dbscan_min_samples=15,
            use_vectorized_cfar=True
        )
    
    def analyze(self, audio_data: np.ndarray) -> Dict:
        """
        Analizeaza complet un semnal audio
        
        Returns:
            Dictionar cu rezultate complete
        """
        print("\n[ANALIZA CFAR-STFT]")
        print("="*50)
        
        # Detectam componente
        components = self.cfar_detector.detect_components(audio_data)
        
        # Clasificam fiecare componenta (heuristic, nu ML)
        classifications = []
        
        for comp in components:
            aircraft_type, confidence = self._classify_component(comp)
            
            # Estimam distanta
            distance = self._estimate_distance(comp)
            
            classifications.append({
                'component': comp,
                'aircraft_type': aircraft_type,
                'confidence': confidence,
                'distance_m': distance,
                'frequency_hz': comp.centroid_freq,
                'time_s': comp.centroid_time,
                'energy': comp.energy
            })
            
            print(f"\n   Componenta {comp.cluster_id}:")
            print(f"      Tip: {aircraft_type} (incredere: {confidence:.1%})")
            print(f"      Frecventa: {comp.centroid_freq:.0f} Hz")
            print(f"      Distanta est.: {distance:.0f} m")
        
        return {
            'n_components': len(components),
            'classifications': classifications,
            'stft': self.cfar_detector.stft_result,
            'detection_map': self.cfar_detector.detection_map
        }
    
    def _classify_component(self, component: DetectedComponent) -> Tuple[str, float]:
        """
        Clasificare bazata pe reguli (heuristic)
        
        Pentru clasificare ML, ar trebui:
        1. Extras features (log-mel, spectral centroid, etc.)
        2. Folosit un model antrenat (SVM, RandomForest, CNN)
        """
        freq = component.centroid_freq
        best_match = 'unknown'
        best_score = 0
        
        for aircraft_type, sig in self.AIRCRAFT_SIGNATURES.items():
            f_min, f_max = sig['freq_range']
            
            # Verificam daca frecventa e in interval
            if f_min <= freq <= f_max:
                # Scor bazat pe distanta de la fundamental
                dist_to_fund = abs(freq - sig['fundamental']) / sig['fundamental']
                base_score = max(0, 1 - dist_to_fund)
                
                # Bonus pentru armonice
                for harmonic in sig['harmonics']:
                    if abs(freq - harmonic) < harmonic * 0.1:  # 10% toleranta
                        base_score += 0.2
                
                if base_score > best_score:
                    best_score = base_score
                    best_match = aircraft_type
        
        confidence = min(1.0, best_score)
        return best_match, confidence
    
    def _estimate_distance(self, component: DetectedComponent) -> float:
        """
        Estimare distanta bazata pe energie (model simplificat)
        
        Model: Atenuare geometrica (spherical spreading) + absorbtie atmosferica
        L(d) = L_0 - 20*log10(d/d_0) - alpha*d
        
        NOTA: Aceasta este o aproximare; distanta reala depinde de:
        - Calibrarea microfonului
        - Nivelul SPL al sursei
        - Conditiile atmosferice
        - Absorbtia dependenta de frecventa
        """
        # Energie normalizata
        energy_db = 10 * np.log10(component.energy + 1e-10)
        
        # Parametri model (placeholder)
        ref_energy_db = 80  # Energie de referinta la 100m
        ref_distance = 100  # m
        
        # Estimare primara (doar spreading geometric)
        delta_db = ref_energy_db - energy_db
        
        if delta_db <= 0:
            return ref_distance / 2
        
        distance = ref_distance * (10 ** (delta_db / 20))
        
        # Limitare realista
        return max(10, min(distance, 20000))


def demo_cfar_detection():
    """Demo pentru detectia CFAR-STFT"""
    print("="*70)
    print("DEMO: Detectie GOCA-CFAR-STFT (bazat pe paper)")
    print("="*70)
    
    # Generam semnal de test multicomponent
    fs = 44100
    duration = 5.0
    t = np.linspace(0, duration, int(fs * duration))
    
    # Componenta 1: Chirp (semnal FM)
    f0, f1 = 500, 2000
    chirp = signal.chirp(t, f0, duration, f1) * 0.8
    
    # Componenta 2: Ton constant
    tone = np.sin(2 * np.pi * 800 * t) * 0.6
    
    # Componenta 3: Puls
    pulse = np.zeros_like(t)
    pulse_start = int(0.5 * fs)
    pulse_end = int(0.7 * fs)
    pulse[pulse_start:pulse_end] = np.sin(2 * np.pi * 1500 * t[pulse_start:pulse_end]) * 0.7
    
    # Zgomot
    noise = np.random.randn(len(t)) * 0.05
    
    # Semnal total
    test_signal = chirp + tone + pulse + noise
    
    print(f"\nSemnal de test: {duration}s, {fs} Hz")
    print("Componente: chirp (500-2000 Hz), ton (800 Hz), puls (1500 Hz)")
    
    # Aplicam detectorul
    detector = CFARSTFTDetector(
        sample_rate=fs,
        window_size=1024,
        hop_size=256,
        cfar_guard_cells=2,
        cfar_training_cells=4,
        cfar_pfa=1e-2,
        dbscan_eps=5.0,
        dbscan_min_samples=5,
        use_vectorized_cfar=True
    )
    
    components = detector.detect_components(test_signal)
    
    print(f"\nComponente detectate: {len(components)}")
    for comp in components:
        print(f"   Cluster {comp.cluster_id}: freq={comp.centroid_freq:.0f} Hz, "
              f"time={comp.centroid_time:.2f}s, energy={comp.energy:.2e}")
    
    return detector, components


if __name__ == "__main__":
    demo_cfar_detection()
