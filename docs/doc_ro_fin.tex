% Documentație conform template FMI (report, Times, 1.5 line spacing)
% Autori: Ingrid Corobana, Teodora Nae
% Compilare recomandată: xelatex doc_ro_fin.tex

\documentclass[11pt, a4paper]{report}

% Suport pentru diacritice și alte simboluri
\usepackage{fontspec}

% Font Times New Roman
\usepackage{times}

% Suport pentru mai multe limbi
\usepackage{polyglossia}

% Setează limba textului la română
\setdefaultlanguage{romanian}
% Am nevoie de engleză pentru rezumat
\setotherlanguages{english}

% Indentează și primul paragraf al fiecărei noi secțiuni
\SetLanguageKeys{romanian}{indentfirst=true}

% Suport pentru diferite stiluri de ghilimele
\usepackage{csquotes}

\DeclareQuoteStyle{romanian}
  {\quotedblbase}
  {\textquotedblright}
  {\guillemotleft}
  {\guillemotright}

% Setează spațiere inter-linie la single (compress)
\usepackage{setspace}
\singlespacing

% Modificarea geometriei paginii (cu margini mai mici - 0.5 inch)
\usepackage[margin=0.5in]{geometry}

% Include funcțiile de grafică
\usepackage{graphicx}
% Încarcă imaginile din directoarele specificate
\graphicspath{{./images/}{../results/ipix_figures/}{../results/evaluation/}}

% Pachete matematice
\usepackage{amsmath}
\usepackage{amssymb}

% Algoritmi
\usepackage{algorithm}
\usepackage{algpseudocode}

% Listări de cod
\usepackage{listings}

% Culori
\usepackage{xcolor}

% Linkuri interactive în PDF
\usepackage[
    colorlinks,
    linkcolor={black},
    menucolor={black},
    citecolor={black},
    urlcolor={blue}
]{hyperref}

% Tabele
\usepackage{array}
\usepackage{booktabs}
\usepackage{float}
\usepackage{caption}
\usepackage{multirow}

% Reduce caption spacing
\captionsetup{skip=3pt}

% Pentru includerea PDF-urilor
\usepackage{pdfpages}

% Pachete pentru figurile complexe TikZ
\usepackage{tikz}
\usetikzlibrary{arrows.meta,positioning,fit,calc,shadows.blur,backgrounds}

% Reduce spacing around sections (aggressive but balanced)
\usepackage{titlesec}
\titlespacing{\chapter}{0pt}{2pt}{1pt}
\titlespacing{\section}{0pt}{2pt}{1pt}
\titlespacing{\subsection}{0pt}{1pt}{0pt}

% Reduce spacing in lists
\usepackage{enumitem}
\setlist{nosep}

% Reduce table row height
\renewcommand{\arraystretch}{0.75}

% Reduce space around equations
\setlength{\abovedisplayskip}{3pt}
\setlength{\belowdisplayskip}{3pt}
\setlength{\abovedisplayshortskip}{2pt}
\setlength{\belowdisplayshortskip}{2pt}

% Reduce space around floats (figures, tables)
\setlength{\floatsep}{3pt}
\setlength{\textfloatsep}{3pt}
\setlength{\intextsep}{2pt}

% Reduce paragraph spacing (but keep readable)
\setlength{\parskip}{4pt plus 2pt}

% Stiluri diferite de headere și footere
\usepackage{fancyhdr}

\definecolor{stftblue}{RGB}{66, 133, 244}
\definecolor{cfarorange}{RGB}{255, 152, 0}
\definecolor{dbscangreen}{RGB}{76, 175, 80}
\definecolor{maskpurple}{RGB}{156, 39, 176}
\definecolor{istftred}{RGB}{244, 67, 54}
\definecolor{signalgray}{RGB}{96, 96, 96}
\definecolor{darkblue}{RGB}{25, 50, 100}
\definecolor{codegray}{RGB}{240, 240, 240}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codegray},
    breaklines=true,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    identifierstyle=\color{darkblue},
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

% Metadate
\title{Analiza semnalelor radar în prezența sea clutter}
\author{Ingrid Corobana \quad Teodora Nae}

% Generează variabilele cu @
\makeatletter

% Suport pentru rezumat în două limbi
\newenvironment{abstractpage}
  {\cleardoublepage\thispagestyle{empty}}
  {\cleardoublepage}
\renewenvironment{abstract}[1]
  {\bigskip\selectlanguage{#1}%
   \begin{center}\bfseries\abstractname\end{center}}
  {\par\bigskip}

\begin{document}

% ============================================================================
% PAGINA DE TITLU - Format FMI
% ============================================================================
\begin{titlepage}
\newgeometry{left=2cm,right=2cm,top=1.5cm,bottom=1cm}
\begin{singlespace}

\begin{figure}[!htb]
    \centering
    \begin{minipage}{0.18\textwidth}
        \includegraphics[width=\linewidth]{logo-ub.png}
    \end{minipage}
    \begin{minipage}{0.55\textwidth}
        \begin{center}
            \textbf{UNIVERSITATEA DIN BUCUREȘTI}\\[0.2cm]
            \textbf{FACULTATEA DE MATEMATICĂ ȘI INFORMATICĂ}
        \end{center}
    \end{minipage}
    \begin{minipage}{0.18\textwidth}
        \includegraphics[width=\linewidth]{logo-fmi.png}
    \end{minipage}
\end{figure}

\vspace{0.3cm}
\begin{center}
\textbf{Specializarea: Informatică}
\end{center}

\vspace{0.8cm}

\begin{center}
\Large \textbf{Proiect la Procesarea Semnalelor}
\end{center}

\vspace{0.5cm}

\begin{center}
\LARGE \textbf{ANALIZA SEMNALELOR RADAR ÎN PREZENȚA SEA CLUTTER}
\end{center}

\vspace{0.3cm}

\begin{center}
\large Abordare bazată pe CFAR-STFT și experimente pe date sintetice și reale
\end{center}

\vspace{1.5cm}

\begin{center}
\large \textbf{Studenți}\\[0.1cm]
Ingrid Corobana\\
Teodora Nae
\end{center}

\vspace{0.8cm}

\begin{center}
\large \textbf{Coordonator științific}\\[0.1cm]
Prof. Dr. Cristian Rusu
\end{center}

\vspace{1.2cm}

\begin{center}
\small \textbf{Repository GitHub:} \url{https://github.com/dirgnic/Radar_Detection_STFT}
\end{center}

\vspace{0.8cm}

\begin{center}
\Large \textbf{București, 2026}
\end{center}

\end{singlespace}
\end{titlepage}

\restoregeometry
\newgeometry{margin=2.5cm}

% ============================================================================
% PAGINA DE REZUMAT
% ============================================================================
\begin{abstractpage}

\begin{abstract}{romanian}
Acest document prezintă o implementare completă a algoritmului \textbf{CFAR--STFT}, propus de \textbf{Abratkiewicz (2022)}, pentru detecția și reconstrucția semnalelor radar în prezența zgomotului și a sea clutter. Algoritmul combină \textbf{Short-Time Fourier Transform (STFT)}, \textbf{detecție adaptivă CFAR 2D}, \textbf{clustering DBSCAN} și \textbf{dilatare geodezică} pentru a extrage componenta de interes dintr-un amestec cu sea clutter.

Implementarea este validată pe date sintetice (chirp neliniar) și pe date reale (\textbf{IPIX radar}, sea clutter). Pe semnalul sintetic controlat, algoritmul detectează componenta de interes în toate cele 100 de rulări Monte Carlo ($P_d = 1.00$). \textbf{RQF} (Reconstruction Quality Factor) crește de la \textbf{7.28 dB} (SNR = 5 dB) la \textbf{29.17 dB} (SNR = 30 dB).

\textbf{Contribuția principală}: adaptăm algoritmul la sea clutter real folosind \textbf{K-distribution} (în loc de Gaussian), \textbf{îmbunătățire bazată pe proprietăți fractale (exponentul Hurst)} pentru ținte slabe și \textbf{DBSCAN asimetric} pentru clustering de semnături verticale.

\textbf{Cuvinte cheie:} CFAR, STFT, radar, sea clutter, K-distribution, DBSCAN, detecție adaptivă
\end{abstract}

\newpage

\begin{abstract}{english}
This document presents a complete implementation of the \textbf{CFAR-STFT} algorithm, proposed by \textbf{Abratkiewicz (2022)}, for detection and reconstruction of radar signals in the presence of noise and sea clutter. The algorithm combines \textbf{Short-Time Fourier Transform (STFT)}, \textbf{2D adaptive CFAR detection}, \textbf{DBSCAN clustering}, and \textbf{geodesic dilation} to extract the component of interest from a mixture with sea clutter.

The implementation is validated on synthetic data (nonlinear chirp) and real data (\textbf{IPIX radar sea clutter}). On controlled synthetic signal, the algorithm detects the component of interest in all 100 Monte Carlo runs ($P_d = 1.00$). \textbf{RQF} (Reconstruction Quality Factor) increases from \textbf{7.28 dB} (SNR = 5 dB) to \textbf{29.17 dB} (SNR = 30 dB).

\textbf{Key contribution}: we adapt the algorithm to real sea clutter using \textbf{K-distribution} (instead of Gaussian), \textbf{fractal-based enhancement (Hurst exponent)} for weak targets, and \textbf{asymmetric DBSCAN} for vertical signature clustering.

\textbf{Keywords:} CFAR, STFT, radar, sea clutter, K-distribution, DBSCAN, adaptive detection
\end{abstract}

\end{abstractpage}

% ============================================================================
% CUPRINS
% ============================================================================
\tableofcontents

% ============================================================================
% CONFIGURARE PAGINI PRINCIPALE
% ============================================================================
\cleardoublepage
\fancypagestyle{main}{
  \fancyhf{}
  \renewcommand\headrulewidth{0pt}
  \fancyhead[C]{}
  \fancyfoot[C]{\thepage}
}
\pagestyle{main}

% ============================================================================
% CAPITOLUL 1: INTRODUCERE
% ============================================================================
\chapter{Introducere}

Problema principală abordată este \textbf{detecția obiectelor mici în date radar maritime}, într-un mediu complex. Mediul acvatic are caracteristici particulare: (1) statisticile \textbf{nu sunt bine modelate Gaussian} (valori extreme frecvente), (2) există \textbf{corelație temporală} (valuri cu tipare structurate), (3) efectele Doppler \textbf{extind spectrul} (valuri în mișcare), (4) apar \textbf{vârfuri de energie (spikes)} vizibile când valurile sunt mari.

Metodele tradiționale adaptive de detecție \textbf{CFAR} (Constant False Alarm Rate) pot fi limitate atunci când pierd informația temporală și nu exploatează structura timp--frecvență. Abratkiewicz (2022)\footnote{Abratkiewicz, K. (2022). Radar Detection-Inspired Signal Retrieval from the Short-Time Fourier Transform. Sensors, 22(16), 5954.} propune o abordare care folosește explicit structura \textbf{time--frequency} pentru a îmbunătăți atât \textbf{detecția}, cât și \textbf{recuperarea/reconstrucția} componentelor semnalului.





% ============================================================================
% CAPITOLUL 2: STADIUL ACTUAL (FUNDAMENTE TEORETICE)
% ============================================================================
% ============================================================================
% CAPITOLUL 2: DESCRIEREA COMPLETĂ A ALGORITMULUI
% ============================================================================
\chapter{Descrierea completă a algoritmului}

\section{Fundamente teoretice și STFT}

\subsection{STFT -- Transformata Fourier pe Ferestre Scurte}

\begin{equation}
X(k,n) = \sum_{m=0}^{N-1} x(m) \cdot w(m - nH) \cdot e^{-j2\pi km/N}
\end{equation}
cu $N=256$, $H=32$ (87.5\% overlap), fereastră Gaussiană $w(m) = e^{-m^2/(2\sigma^2)}$, $\sigma=8$.

\subsection{CFAR 2D (GOCA-CFAR)}

Detecție adaptivă cu prag local: $H(k,n) = 1$ dacă $|X(k,n)|^2 > T$, unde
\begin{equation}
T = R \cdot \hat{Z}, \quad \hat{Z} = \max(\mu_1, \mu_2, \mu_3, \mu_4), \quad R = N_T (P_{fa}^{-1/N_T} - 1)
\end{equation}

\subsection{DBSCAN}

Clustering pe densitate cu distanță asimetrică pentru semnături verticale: $d = \sqrt{\Delta t^2 + (\Delta f/3)^2}$.

\section{Pipeline general (5 pași)}

Algoritmul complet constă din cinci etape:

\noindent
\textbf{(1)} Calcul STFT cu fereastră Gaussiană ($N_{fft}=256$, hop=32, $\sigma=8$). \\[0.15cm]
\textbf{(2)} Detecție CFAR 2D în plan timp--frecvență: calculează media puterii în 4 cadrane pentru fiecare bin $(k,n)$, iar pragul $T = R \cdot \max(\mu_1, \mu_2, \mu_3, \mu_4)$ decide dacă $|X(k,n)|^2 > T$ (parametri: $P_f=0.001$, $N_G=3$, $N_T=12$). \\[0.15cm]
\textbf{(3)} Clustering DBSCAN: aplică distanța asimetrică din ecuația (3) pentru a grupa punctele detectate $(k,n)$ cu parametri $\varepsilon=8$, minSamples=5. \\[0.15cm]
\textbf{(4)} Dilatare geodezică: expandează detecțiile aplicând kernel cruce (3×3) de 3 ori cu \texttt{maximum\_filter} pentru a conecta punctele apropiate. \\[0.15cm]
\textbf{(5)} Extragere detecții: aplică masca pe STFT $X_{\text{masked}} = X_{\text{STFT}} \odot H_{\text{dil}}$ și extrage binarele detectate.

\begin{figure}[H]
\centering
\begin{tikzpicture}[
    node distance=1.4cm and 1.6cm,
    box/.style={rectangle, draw, rounded corners, minimum width=2.2cm, minimum height=0.8cm, align=center, font=\tiny\bfseries},
    arrow/.style={-{Stealth[length=2mm]}, thick},
    label/.style={font=\tiny, align=center},
    eqlabel/.style={font=\tiny, text=gray}
]

% Rândul 1: Input -> STFT -> CFAR
\node[box, fill=signalgray!20] (input) {Semnal de intrare\\$x[n]$};

\node[box, fill=stftblue!30, right=of input] (stft) {STFT\\Gaussiană $\sigma=8$};

\node[box, fill=cfarorange!30, right=of stft] (cfar) {GOCA-CFAR 2D\\$P_f=0.001$};

% Rândul 2: DBSCAN -> Mask -> Detecții
\node[box, fill=dbscangreen!30, below=2cm of cfar] (dbscan) {DBSCAN\\Clustering};

\node[box, fill=maskpurple!30, below=2cm of stft] (mask) {Mask Expansion\\Geodesic Dilation};

\node[box, fill=istftred!30, below=2cm of input] (output) {Detecții\\finale};

% Rândul 3: Output
\node[box, fill=signalgray!20, below=2cm of mask] (final) {Ținte detectate};

% Săgeți rândul 1
\draw[arrow] (input) -- node[above, label] {$x[n]$} (stft);
\draw[arrow] (stft) -- node[above, label] {$|F_x^h|^2$} (cfar);

% Săgeți verticale și rândul 2
\draw[arrow] (cfar) -- node[right, label] {Mască\\binară} (dbscan);
\draw[arrow] (dbscan) -- node[above, label] {Clustere} (mask);
\draw[arrow] (mask) -- node[above, label] {Măști} (output);

% Săgeată finală
\draw[arrow] (output) -- (final);

\end{tikzpicture}
\caption{Pipeline-ul complet al algoritmului CFAR-STFT pentru detecția componentelor din planul timp-frecvență.}
\label{fig:pipeline}
\end{figure}

\subsection{Pasul 2: Structura CFAR 2D}

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.65]
    % Grid background
    \draw[step=1, gray!30, very thin] (-5.5,-5.5) grid (5.5,5.5);
    
    % Training cells (outer ring)
    \fill[cfarorange!40] (-5,-5) rectangle (5,5);
    
    % Guard cells (middle ring)
    \fill[yellow!40] (-3,-3) rectangle (3,3);
    
    % CUT (center)
    \fill[red!60] (-0.5,-0.5) rectangle (0.5,0.5);
    
    % Labels pentru regiuni
    \node at (0,0) {\textbf{CUT}};
    \node at (0,2) {\small Guard};
    \node at (0,4) {\small Training};
    
    % Dimensiuni
    \draw[{Stealth}-{Stealth}, thick] (-5,-6) -- (5,-6);
    \node at (0,-6.5) {$2(N_G + N_T) + 1$};
    
    \draw[{Stealth}-{Stealth}, thick] (-3,-5.3) -- (3,-5.3);
    \node at (0,-5.8) {\scriptsize $2N_G + 1$};
    
    % GOCA regions
    \draw[thick, blue, dashed] (-5,0.5) rectangle (-0.5,5);
    \draw[thick, green!70!black, dashed] (0.5,0.5) rectangle (5,5);
    \draw[thick, purple, dashed] (-5,-5) rectangle (-0.5,-0.5);
    \draw[thick, orange!80!black, dashed] (0.5,-5) rectangle (5,-0.5);
    
    \node[blue, font=\scriptsize] at (-2.75,2.75) {$\mu_1$};
    \node[green!70!black, font=\scriptsize] at (2.75,2.75) {$\mu_2$};
    \node[purple, font=\scriptsize] at (-2.75,-2.75) {$\mu_3$};
    \node[orange!80!black, font=\scriptsize] at (2.75,-2.75) {$\mu_4$};
    
\end{tikzpicture}
\hspace{1cm}
\begin{tikzpicture}[scale=0.85]
    % Formula box
    \node[draw, rounded corners, fill=gray!10, minimum width=5.5cm, minimum height=4cm, align=left] (formulas) {
        \textbf{GOCA-CFAR:}\\[0.3em]
        $\hat{Z} = \max(\mu_1, \mu_2, \mu_3, \mu_4)$\\[0.3em]
        $T = R \cdot \hat{Z}$\\[0.3em]
        $R = N_T \cdot (P_f^{-1/N_T} - 1)$\\[0.8em]
        \textbf{Decizie:}\\[0.3em]
        $|F_x^h[m,k]|^2 \geq T \Rightarrow$ \textcolor{green!60!black}{Det}\\
        $|F_x^h[m,k]|^2 < T \Rightarrow$ \textcolor{red}{Zgomot}
    };
\end{tikzpicture}
\caption{Structura celulelor GOCA-CFAR 2D: CUT (roșu), Guard (galben), Training (portocaliu). GOCA calculează media în 4 sub-regiuni și ia maximul pentru adaptare locală.}
\label{fig:cfar}
\end{figure}

% ============================================================================
% CAPITOLUL 3: DATE ȘI SURSE DE VALIDARE
% ============================================================================
\chapter{Date și surse de validare}

\section{Baza de date IPIX}

IPIX (McMaster University): radar X-band ($f_{RF}=9.39$ GHz, PRF=1000 Hz), date complexe I/Q. Ținte reale (sferă 1m la 2660m): \#17, \#18, \#30, \#40.

\section{Experimente pe semnale sintetice}

S-au rulat 100 simulări Monte Carlo pentru fiecare nivel SNR, chirp neliniar, rata 100\%.

Metrica RQF:
\begin{equation}
\text{RQF} = 10 \log_{10}\left(\frac{\sum_n |x[n]|^2}{\sum_n |x[n] - \hat{x}[n]|^2}\right) \text{ [dB]}
\end{equation}

\begin{table}[H]
\centering
\vspace{-4pt}
\caption{Rezultate CFAR-STFT (100 MC)}
\label{tab:results_synthetic}
\begin{tabular}{ccccc}
\toprule
\textbf{SNR} & \textbf{RQF\_mean} & \textbf{RQF\_std} & \textbf{P\_d [\%]} & \textbf{N} \\
\midrule
5 & 7.28 & 0.47 & 100 & 100 \\
10 & 16.81 & 0.60 & 100 & 100 \\
15 & 22.95 & 0.56 & 100 & 100 \\
20 & 26.40 & 0.51 & 100 & 100 \\
25 & 28.43 & 0.39 & 100 & 100 \\
30 & 29.17 & 0.25 & 100 & 100 \\
\bottomrule
\end{tabular}
\vspace{-4pt}
\end{table}

\begin{figure}[H]
\centering
\vspace{-4pt}
\includegraphics[width=0.42\textwidth]{../results/evaluation/rqf_vs_snr_annotated.pdf}
\hfill
\includegraphics[width=0.42\textwidth]{../results/evaluation/detection_rate_vs_snr_annotated.pdf}
\caption{Performanță vs SNR cu adnotări: RQF și rata detecție 100\% (SNR 5-30 dB cu marcare punctelor).}}
\label{fig:snr_performance}
\vspace{-4pt}
\end{figure}

\section{Analiză comparativă: Algoritmi CFAR și Clustering}

\subsection{Principii fundamentale CFAR}

CFAR menține rata alarmelor false constantă: (1) fereastră glisantă cu CUT, guard cells, training cells; (2) prag adaptiv $T = \alpha Z$; (3) detecție dacă $CUT \ge T$.

\subsection{Algoritmi CFAR}

CA-CFAR: media aritmetică, robustă în zgomot omogen. OS-CFAR: percentilă, robust la interferențe. SOCA-CFAR: minim subregiuni, optim la marginile dense.

\subsection{CFAR: Formule și pseudocod}

\begin{table}[H]
\centering
\small
\renewcommand{\arraystretch}{2.5}
\begin{tabular}{@{} l p{4cm} p{7.5cm} @{}}
\toprule
\textbf{Metodă} & \textbf{Model matematic} & \textbf{Pseudocod simplificat} \\ \midrule

CA-CFAR & 
$Z = \frac{1}{N_T} \sum_{i=1}^{N_T} x_i$, $T = R \cdot Z$ & 
\textbf{1.} Extrage celulele de antrenament $S_{train}$ (fără zona de gardă) \newline
\textbf{2.} $Z = \text{mean}(S_{train})$ \newline
\textbf{3.} IF $CUT \ge T$ THEN detecție \\ \midrule

OS-CFAR & 
$Z = x_{(k)}$, $T = \alpha \cdot Z$ &
\textbf{1.} Sortează $S_{train}$ → $S_{sorted}$ \newline
\textbf{2.} $Z = S_{sorted}[k]$ (valoarea de rang k) \newline
\textbf{3.} IF $CUT \ge T$ THEN detecție \\ \midrule

SOCA-CFAR &
$Z = \min(\mu_1, \dots, \mu_4)$, $T = R \cdot Z$ &
\textbf{1.} Împarte fereastra în 4 subregiuni \newline
\textbf{2.} Calculează media $\mu_i$ pentru fiecare subregiune \newline
\textbf{3.} $Z = \min(\mu_{1}, \dots, \mu_4)$ \newline
\textbf{4.} IF $CUT \ge T$ THEN detecție \\ 

\bottomrule
\end{tabular}
\caption{Formule și pseudocod pentru metodele CFAR}
\end{table}

\subsection{Metode de clustering}

\begin{table}[H]
\centering
\small
\renewcommand{\arraystretch}{2.0}
\begin{tabular}{@{} l p{3.5cm} p{7.5cm} @{}}
\toprule
\textbf{Metodă} & \textbf{Descriere conceptuală} & \textbf{Pseudocod} \\ \midrule

Agglomerative & 
Ierarhic \textit{bottom-up}. Fuzionează succesiv perechile cele mai apropiate. & 
\textbf{1.} Normalizează punctele $(f, t)$ \newline
\textbf{2.} Fiecare punct = cluster individual \newline
\textbf{3.} WHILE nr\_clustere $> K$: \newline
\hspace{1em} Găsește clusterele cu $d_{min}$ \newline
\hspace{1em} Unește-le sub aceeași etichetă \newline
\textbf{4.} Reindexează etichetele (0, 1, 2...) \\ \midrule

HDBSCAN & 
Bazat pe densitate ierarhică. Folosește \textit{core distance} și \textit{MST} pentru stabilitate. & 
\textbf{1.} Normalizează punctele $(f, t)$ \newline
\textbf{2.} Calculează \textbf{core distance} $(c)$ pentru fiecare punct \newline
\textbf{3.} Determină \textbf{MRD}: $d_{mrd}(u,v) = \max(c(u), c(v), d(u,v))$ \newline
\textbf{4.} Construiește \textbf{MST} folosind MRD \newline
\textbf{5.} Extrage componente conexe cu prag $\varepsilon$ \newline
\textbf{6.} Elimină clusterele sub $min\_samples$ $\to$ zgomot (-1) \\ \midrule

DBSCAN & 
Bazat pe densitate & 
Grupeaza puncte cu distanță $\le \varepsilon$. Asymetric: $d = \sqrt{\Delta t^2 + (\Delta f / \text{freq\_scale})^2}$ \\
\bottomrule
\end{tabular}
\caption{Metode de clustering utilizate}
\end{table}

\subsection{Separare prin triangulare Delaunay}

Alternativă geometrică la CFAR + clustering:

\begin{table}[H]
\centering
\small
\renewcommand{\arraystretch}{2.5}
\begin{tabular}{@{} l p{3.5cm} p{7.5cm} @{}}
\toprule
\textbf{Pas} & \textbf{Idee} & \textbf{Pseudocod simplificat} \\ \midrule

Detectare Vârfuri &
Maxime locale în spectrograma STFT, filtrate prin prag percentilă:
\[
\text{peak}(i,j) = \begin{cases} 1 & \text{dacă } S_{i,j} = \max(\text{vecini}) \text{ și } S_{i,j} > T \\ 0 & \text{altfel} \end{cases}
\]
& 
\textbf{1.} Calcul STFT și magnitudine \newline
\textbf{2.} Threshold = magnitudinea percentilei \newline
\textbf{3.} Identifică maxime locale în fereastră \newline
\textbf{4.} Returnează coordonate vârfuri \\ \midrule

Triangulare Delaunay &
Construiește triunghiuri pentru punctele detectate. Criteriu: niciun punct în cercul circumscris al unui triunghi existent & 
\textbf{1.} Creează triunghi inițial care înconjoară toate punctele \newline
\textbf{2.} Pentru fiecare punct nou: identifică triunghiuri care încalcă criteriul \newline
\textbf{3.} Elimină triunghiurile și formează poligonul gol \newline
\textbf{4.} Creeaza triunghiuri noi: punct curent + fiecare latură a poligonului \newline
\textbf{5.} Elimină triunghiurile cu vârfuri din super-triunghi \\ \midrule

Gruparea triunghiurilor &
Triunghiuri vecine conectate după energie medie, dacă au muchie comună & 
\textbf{1.} Construiește lista muchiilor pentru toate triunghiurile \newline
\textbf{2.} Adaugă muchiile comune ca legături dacă diferența relativă magnitudine $< \varepsilon$ \newline
\textbf{3.} Parcurgere DFS pentru identificare componente conexe \newline
\textbf{4.} Calculează puncte, energie, centroid pentru fiecare componentă \\
\bottomrule
\end{tabular}
\caption{Sinteză a pașilor de separare prin triangulare Delaunay și pseudocod asociat}
\end{table}

\subsection{Experimente pe semnale sintetice controlate}

\textbf{Metodă 1: CA-CFAR + HDBSCAN:} STFT Hamming, CA-CFAR, HDBSCAN clustering, reconstrucție componentă, evaluare RQF.

\textbf{Metodă 2: Triangulare Delaunay:} STFT Gaussiană, maxime locale, triangulare Delaunay timp-frecvență, grupare după energie, Doppler din component dominantă.

\textbf{Rezultate sintetice:}
CA-CFAR+HDBSCAN: 100\% detecție, RQF stabil SNR 5-30 dB. Triangulare: bună SNR mediu/ridicat, variabilitate mai mare RQF.

\section{Experimente pe IPIX cu ținte reale}

S-au efectuat experimente pe date reale din baza IPIX. Figurile de mai jos arată cadre reprezentative din secvențele de detecție:

\begin{figure}[H]
\centering
\vspace{-4pt}
\includegraphics[width=0.85\textwidth]{../results/ipix_figures/ipix_target_17_goca_frame83.pdf}
\caption{GOCA-CFAR pe IPIX Target \#17: spectrograma (stânga), heatmap detecții (centru), detecții cadru (dreapta). Linie verticală = țintă la Doppler pozitiv.}
\label{fig:goca_detection}
\vspace{-4pt}
\end{figure}

\begin{figure}[H]
\centering
\vspace{-4pt}
\includegraphics[width=0.85\textwidth]{../results/ipix_figures/ipix_target_17_fractal_frame83.pdf}
\caption{GOCA-CFAR cu Fractal Boost pe IPIX Target \#17: Hurst exponent boost îmbunătățește detecția țintelor slabe.}
\label{fig:fractal_boost_detection}
\vspace{-4pt}
\end{figure}

\subsection{Setul de Date și Scenarii}

Date IPIX reale: Low Sea State (clutter moderat) vs High Sea State (clutter intens, neomogen). Procesare segmentată 1s, PRF=1000 Hz, I/Q complex.

\subsection{Rezultate comparative: CA-CFAR+HDBSCAN vs. Triangulare Delaunay}

\begin{table}[H]
\centering
\small
\begin{tabular}{@{} l c c c @{}}
\toprule
\textbf{Metodă} & \textbf{Sea State} & \textbf{Componente} & \textbf{Viteza [m/s]} \\ \midrule
\multirow{2}{*}{CA-CFAR + HDBSCAN} 
    & HIGH & $1.0 \pm 0.0$ & $-0.054$ \\
    & LOW  & $1.0 \pm 0.0$ & $-0.008$ \\ \midrule
\multirow{2}{*}{Triangulare Delaunay} 
    & HIGH & $4.2$ & $+1.30$ \\
    & LOW  & $13.6$ & $-0.30$ \\ 
\bottomrule
\end{tabular}
\caption{Performanță comparativă pe IPIX (30 segmente × 1s per scenariu)}
\end{table}

\subsection{Observații Experimentale Detaliate}

\textbf{CA-CFAR + HDBSCAN:} Detecție 100\%, dar produce detecții dominante de clutter; ținta nu izolată ($\sigma = 0$). HDBSCAN grupează întreg clutter-ul. \textbf{Concluzie:} CA-CFAR nu separă ținta de clutter neomogen.

\textbf{Triangulare Delaunay:} Detecție ridicată dar instabilă. HIGH sea: 4.2 comp., LOW sea: 13.6 comp. (neașteptat). Doppler variază 4×: +1.30 vs. -0.30 m/s. Metoda fragmentează clutter. \textbf{Concluzie:} Variabilitate prea mare.

\subsection{Concluzie validată experimental}

Pentru sea clutter real neomogen: CA-CFAR nu separă ținta (variabilitate zero). Triangularea oferă detecție dar variabilitate mare. \textbf{GOCA-CFAR + DBSCAN anisotropic} (această implementare) oferă cea mai bună performanță cu detecții stabile.

\textbf{Motivul succesului:} (1) GOCA adaptează prag pe 4 cadrane local, (2) DBSCAN anisotropic ($\text{freq\_scale}=3.0$) păstrează coeziune ținte (linii verticale), (3) K-distribution + Hurst + DC masking + Doppler filter elimină alarmele false din clutter sever.


\label{chap:adaptations}

Modificări cheie pentru adaptarea algoritmului din articol la sea clutter real:

Sea clutter-ul urmează \textbf{K-distribution} cu pdf: $p(x) = \frac{4}{\Gamma(\nu)} \left(\frac{\nu x^2}{2\mu}\right)^{(\nu+1)/2} K_{\nu-1}\left(\sqrt{\frac{2\nu x^2}{\mu}}\right)$ (cozi mai grele decât Gaussian, se estimează $\nu = \mu^2 / (\sigma^2 - \mu^2)$ și se ajustează pragul pentru reducerea alarmelor false). Sea clutter prezintă \textbf{exponent Hurst} cu proprietatea $\mathbb{E}\left[|X(t+\tau) - X(t)|^2\right] \propto \tau^{2H}$ unde $H \approx 0.75$--$0.85$ pentru clutter și $H < 0.6$ pentru ținte; se aplică mască combinată: $\text{CFAR} \lor (\text{Hurst anomaly} \land \text{putere mare})$. \textbf{DBSCAN cu metrică anisotropică}: țintele apar ca semnături aproape verticale în plan timp–frecvență (variație mare pe frecvență, redusă în timp), deci se folosește $d = \sqrt{(\Delta t)^2 + \left(\frac{\Delta f}{3.0}\right)^2}$ pentru a menține coeziunea unei ținte. Măști suplimentare: (i) $\pm 8$ bin-uri în jurul frecvenței zero (DC) pentru eliminarea returnărilor staționare; (ii) respingere clustere cu lățime Doppler $< 3$ Hz pentru filtrarea detecțiilor neplauzibile fizic.

% ============================================================================
% CAPITOLUL 4: DETALII DE IMPLEMENTARE
% ============================================================================
\chapter{Detalii de implementare}

\section{Framework și tehnologii}

Implementarea utilizează Python 3 cu bibliotecile: NumPy pentru operații matriceale, SciPy pentru STFT și algoritmi de clustering (DBSCAN, HDBSCAN), Matplotlib pentru vizualizare. Prelucrarea se realizează într-o buclă secvențială pe segmente de semnal, cu stocarea spectrogramelor în memorie. Structuri de date principale: array-uri NumPy (spectrogramă complexă, detecții binare), liste de clustere (perechi tempo-frecvență). Paralelismul poate fi introdus cu multiprocessing pe nivel de fișier (procesare independentă a mai multor semnale radar).

\section{Parametri și calibrare}

\begin{table}[H]
\centering
\caption{Parametrii algoritmului -- valori utilizate}
\begin{tabular}{lccc}
\toprule
\textbf{Parametru} & \textbf{Valoare} & \textbf{Interval} & \textbf{Semnificație} \\
\midrule
$N_{fft}$ (window\_size) & 256 & $[128, 512]$ & Lungime FFT \\
$H$ (hop\_size) & 32 & $[N/8, N/2]$ & Hop = 87.5\% overlap \\
$\sigma_{window}$ & 8 & [4, 16] & Deviația std. a ferestrei \\
$P_{fa}$ & $10^{-3}$ & [$10^{-4}$, $10^{-2}$] & Probabilitate alarmă falsă \\
$N_G$ (cfar\_guard) & 3 & [2, 8] & Mărime celule guard \\
$N_T$ (cfar\_training) & 12 & [8, 24] & Mărime celule training \\
$\varepsilon_{DBSCAN}$ & 8 & [4, 16] & Raza de clustering \\
minSamples & 5 & [3, 10] & Puncte minime per cluster \\
freq\_scale & 3.0 & [2, 5] & Scalare metrică anisotropică DBSCAN \\
dc\_mask\_bins & 8 & [4, 16] & Bin-uri DC de mascat \\
min\_doppler\_bw & 3.0 Hz & [1, 10] & Lățime Doppler minimă \\
\bottomrule
\end{tabular}
\end{table}

\section{Notă asupra Doppler}

$v_r = \frac{f_d \cdot c}{2 f_{RF}}$. IPIX: $f_d = +100$ Hz → $v_r \approx +1.6$ m/s, max $\pm 8$ m/s.

% ============================================================================
% CAPITOLUL 5: CONCLUZII ȘI DIRECȚII VIITOARE
% ============================================================================
\chapter{Concluzii și direcții viitoare}

\section{Concluzii}

RQF = 29.17 dB (SNR=30 dB, 100\% Pd), performanță stabilă 5--30 dB, validare IPIX, reproductibilitate GitHub.

\section{Direcții viitoare}

GPU acceleration, calibrare automată, multi-target tracking, ML-based adaptation.

\section{Cod}

Repository GitHub: \url{https://github.com/dirgnic/Radar_Detection_STFT} pentru reproductibilitate și replicare independentă.

\begin{thebibliography}{99}

\bibitem{abratkiewicz2022}
Abratkiewicz, K. (2022).
\textit{Radar Detection-Inspired Signal Retrieval from the Short-Time Fourier Transform}.
Sensors, 22(16), 5954.
\newline \url{https://doi.org/10.3390/s22165954}

\bibitem{ipix}
S. Haykin, et al.,
``IPIX Radar Database,''
McMaster University / DREO, 1993.
\url{http://soma.ece.mcmaster.ca/ipix/}

\bibitem{ward2006}
K. D. Ward, R. J. A. Tough, S. Watts,
\textit{Sea Clutter: Scattering, the K Distribution and Radar Performance},
IET, 2006.

\bibitem{hurst1951}
H. E. Hurst,
``Long-term storage capacity of reservoirs,''
\textit{Trans. Am. Soc. Civil Eng.}, vol. 116, pp. 770-799, 1951.

\bibitem{harris1978}
Harris, F.J. (1978).
\textit{On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform}.
Proceedings of the IEEE, 66(1), 51-83.

\bibitem{ester1996}
Ester, M., Kriegel, H.-P., Sander, J., Xu, X. (1996).
\textit{A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise}.
In KDD'96: Proceedings, pp. 226-231.

\bibitem{rohling1983}
H. Rohling,
``Radar CFAR thresholding in clutter and multiple target situations,''
\textit{IEEE Trans. Aerospace Electron. Syst.}, vol. 19, no. 4, 1983.

\bibitem{richards2005}
Richards, M. A. (2005).
\textit{Fundamentals of Radar Signal Processing}.
McGraw-Hill Professional.

\bibitem{triangulation2023}
Triangulation Separation Method,
\textit{IPIX Radar Target Separation via Delaunay Triangulation}.
Available: Included in \texttt{extensions/triangulation\_separation.py}

\end{thebibliography}

\end{document}
