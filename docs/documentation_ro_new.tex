% Documentație conform șablonului FMI (report, Times, 1.5 line spacing)
% Autori: Ingrid Corobana, Teodora Nae
% Compilare recomandată: xelatex documentation_ro.tex

\documentclass[12pt,a4paper]{report}

% Suport diacritice și font Times (șablon FMI)
\usepackage{fontspec}
\usepackage{times}
\usepackage{polyglossia}
\setdefaultlanguage{romanian}
\setotherlanguages{english}
\SetLanguageKeys{romanian}{indentfirst=true}

\usepackage{geometry}
\usepackage{setspace}
\doublespacing
\geometry{margin=2.5cm}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{array}
\usepackage{booktabs}
\usepackage{float}
\usepackage{caption}
\usepackage{pdfpages} % pentru a include pipeline_diagrams.pdf

\geometry{
    a4paper,
    left=2.5cm,
    right=2.5cm,
    top=2.5cm,
    bottom=2.5cm,
    headheight=14pt
}

\pagestyle{fancy}
\setlength{\headheight}{14.49998pt}
\fancyhf{}
\fancyhead[L]{\textit{Detecția CFAR-STFT}}
\fancyhead[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}

\definecolor{stftblue}{RGB}{66, 133, 244}
\definecolor{cfarorange}{RGB}{255, 152, 0}
\definecolor{dbscangreen}{RGB}{76, 175, 80}
\definecolor{darkblue}{RGB}{25, 50, 100}
\definecolor{codegray}{RGB}{240, 240, 240}

\hypersetup{
    colorlinks=true,
    linkcolor=darkblue,
    urlcolor=stftblue,
    bookmarksnumbered=true,
    pdftitle={Documentație CFAR-STFT}
}

\lstset{
    language=Python,
    basicstyle=\ttfamily\small,
    backgroundcolor=\color{codegray},
    breaklines=true,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    identifierstyle=\color{darkblue},
    numbers=left,
    numberstyle=\tiny\color{gray}
}

\renewcommand{\algorithmicrequire}{\textbf{Intrare:}}
\renewcommand{\algorithmicensure}{\textbf{Ieșire:}}

\title{
    \textbf{\Large Analiza semnalelor radar în prezența ecourilor marine (sea clutter)}\\[0.5em]
    \normalsize Abordare bazată pe CFAR-STFT și experimente pe date sintetice și reale
}

\author{
    Ingrid Corobana \quad Teodora Nae\\
    \small \textit{Procesarea Semnalelor}\\[0.3em]
    \href{https://github.com/dirgnic/Radar_Detection_STFT}{\texttt{github.com/dirgnic/Radar\_Detection\_STFT}}\footnote{Repository: \url{https://github.com/dirgnic/Radar\_Detection\_STFT}}
}

\date{\today}

\begin{document}

\maketitle

\begin{abstract}
Acest document prezintă o implementare completă a algoritmului CFAR-STFT propus de Abratkiewicz (2022) pentru detecția și recuperarea semnalelor radar în prezența zgomotului și al clutter-ului. Algoritmul combină Short-Time Fourier Transform (STFT), detecția adaptivă CFAR 2D, clustering-ul DBSCAN și geodesic dilation pentru a reconstrui semnale radar cu fidelitate ridicată.

Implementarea este validată pe date sintetice (chirp neliniar) și date reale (radar IPIX sea-clutter). Pe semnalul sintetic controlat, algoritmul detectează componenta de interes în toate cele 100 rulări Monte Carlo (100\% detection rate). Reconstruction Quality Factor (RQF) variază de la 7.28 dB la SNR=5dB până la 29.17 dB la SNR=30dB.

Codul sursă este disponibil la: \url{https://github.com/dirgnic/Radar_Detection_STFT}
\end{abstract}

\newpage
\tableofcontents
\newpage

% Secțiune dedicată diagramelor de pipeline pre-generate
\section*{Diagrame Pipeline CFAR-STFT}
\addcontentsline{toc}{section}{Diagrame Pipeline CFAR-STFT}

În această secțiune sunt incluse toate diagramele de tip pipeline generate în fișierul \texttt{pipeline\_diagrams.tex} și compilate în \texttt{pipeline\_diagrams.pdf}. Aceste diagrame descriu:
\begin{itemize}
    \item fluxul complet CFAR-STFT (STFT \textrightarrow{} CFAR \textrightarrow{} DBSCAN \textrightarrow{} dilatare \textrightarrow{} iSTFT);
    \item structura detaliată a ferestrei STFT și a zonelor Guard/Training din CFAR;
    \item pipeline-ul experimentelor pe semnale sintetice și date IPIX;
    \item modul de calcul al vitezei Doppler și legătura cu frecvența;
    \item diagrame de configurare a parametrilor principali.
\end{itemize}

Pe paginile următoare sunt incluse diagramele din fișierul PDF compilat:

\includepdf[pages=1,scale=0.95,offset=0 -20]{pipeline_diagrams.pdf}
\newpage
\includepdf[pages=2-,scale=0.95,offset=0 -20]{pipeline_diagrams.pdf}

\newpage

\section{Introducere}

Detecția fiabilă a semnalelor radar în prezența zgomotului și al clutter-ului rămâne o problemă centrală în sistemele radar moderne. Metodele tradiționale de detecție adaptivă (CFAR, constant false-alarm rate) sunt limitate la domeniul frecvenței, pierdând informațiile temporale importante.

Abratkiewicz (2022)\footnote{Abratkiewicz, K. (2022). Radar Detection-Inspired Signal Retrieval from the Short-Time Fourier Transform. Sensors, 22(16), 5954.} propune o abordare inovatoare care exploatează structura timp-frecvență a semnalelor radar pentru a îmbunătăți atât detecția cât și recuperarea componentelor semnalului.

\subsection{Obiectivele proiectului}

Acest proiect urmărește următoarele obiective:

\begin{enumerate}
    \item Implementarea completă a algoritmului CFAR-STFT în Python
    \item Validarea pe date sintetice (chirp nonliniar conform ecuației 14 din paper)
    \item Testare pe date reale (radar IPIX cu sea-clutter complex)
    \item Analiza Doppler pentru estimarea vitezei obiectelor
    \item Documentație detaliată și reproducibilitate completă
    \item Validare de rezultate: detecție și reconstrucție
\end{enumerate}

\subsection{Structura documentului}

Documentul este organizat după cum urmează:

\begin{itemize}
    \item \textbf{Secțiunea 2}: Fundamente teoretice și formule matematice esențiale
    \item \textbf{Secțiunea 3}: Descrierea detaliată a tuturor pașilor algoritmului cu pseudocod
    \item \textbf{Secțiunea 4}: Rezultate experimentale complete și analiză
    \item \textbf{Secțiunea 5}: Detalii de implementare cu referințe la cod
    \item \textbf{Secțiunea 6}: Concluzii și perspective viitoare
\end{itemize}

\section{Fundamente Teoretice}

\subsection{Short-Time Fourier Transform (STFT)}

STFT este fundamentul algoritmului, oferind o reprezentare timp-frecvență a semnalului:

\begin{equation}
X(k,n) = \sum_{m=0}^{N-1} x(m) \cdot w(m - nH) \cdot e^{-j2\pi km/N}
\end{equation}

unde:
\begin{itemize}
    \item $x(m)$ --- semnalul de intrare
    \item $w(m)$ --- fereastră (Gaussian, $\sigma=8$ bin-uri)
    \item $n$ --- indexul timpului (hop-ul dintre ferestre)
    \item $k$ --- indexul frecvenței
    \item $N$ --- lungimea FFT (512 eșantioane)
    \item $H$ --- hopul între ferestre (256 eșantioane, suprapunere 50\%)
\end{itemize}

\textbf{Fereastră Gaussiană}: 
\begin{equation}
w(m) = e^{-m^2/(2\sigma^2)} \quad \text{cu} \quad \sigma=8 \text{ bin-uri}
\end{equation}

Ferestra Gaussiană este aleasă pentru proprietățile sale de minimizare a scurgerii spectrale (spectral leakage).

\subsection{Detecția Adaptivă CFAR 2D}

CFAR (Constant False-Alarm Rate) este o metodă clasică care adapteaza pragul de detecție local în funcție de nivelul local de zgomot:

\begin{equation}
H(k,n) = \begin{cases}
1 & \text{dacă } |X(k,n)|^2 > \lambda \cdot \mathcal{N}(k,n) \\
0 & \text{altfel}
\end{cases}
\end{equation}

unde $\mathcal{N}(k,n)$ este o estimare a nivelului de zgomot local.

\textbf{GOCA-CFAR (Guard-Cell Order-Statistic CFAR)}: Versiunea folosită în această implementare este:

\begin{equation}
\mathcal{N}(k,n) = \frac{1}{4N_G N_T} \sum_{(i,j) \in \text{Training Cells}} |X(i,j)|^2
\end{equation}

Parametri CFAR:
\begin{itemize}
    \item $P_f = 0.4$ (probabilitate falsă alarmă, calibrată experimental)
    \item $N_G = 16$ (dimensiune Guard Cell - zone centrale)
    \item $N_T = 16$ (dimensiune Training Cell - zone de referință)
\end{itemize}

\subsection{Clustering DBSCAN}

După CFAR, punctele detectate în planul timp-frecvență sunt grupate în clase folosind DBSCAN:

\begin{equation}
\text{DBSCAN}(\text{points}, \varepsilon, \text{minSamples})
\end{equation}

Parametri:
\begin{itemize}
    \item $\varepsilon = 3 \text{ până } 5$ Hz/s (rază de clustering)
    \item minSamples $= 5 \text{ până } 10$ (puncte minime per cluster)
\end{itemize}

\subsection{Reconstruction Quality Factor (RQF)}

Metrica principală pentru evaluare a calității reconstructiei:

\begin{equation}
\text{RQF} = 10 \log_{10}\left(\frac{\sum_{m=0}^{M-1} |x(m)|^2}{\sum_{m=0}^{M-1} |x(m) - \hat{x}(m)|^2}\right) \text{ [dB]}
\end{equation}

unde $x(m)$ este semnalul original și $\hat{x}(m)$ este semnalul reconstruit.

\section{Descrierea Algoritmului Complet}

\subsection{Pipeline General}

Algoritmul complet constă din cinci pași principali:

\begin{enumerate}
    \item Calculul STFT cu fereastră Gaussiană
    \item Detecția adaptivă CFAR 2D în planul timp-frecvență
    \item Clustering DBSCAN al punctelor detectate
    \item Dilatare geodezică a măștii de detecție
    \item Reconstrucția inversă (iSTFT) cu mască
\end{enumerate}

\subsubsection{Pasul 1: Calculul STFT}

\begin{algorithm}[H]
\caption{Calculul STFT cu Fereastră Gaussiană}
\begin{algorithmic}[1]
\Require Semnalul de intrare $x[n]$, lungimea FFT $N_{fft}=512$, hop $H=256$, $\sigma=8$
\Ensure Matricea STFT $X_{stft} \in \mathbb{C}^{N_f \times N_t}$
\State $N_t \gets \lceil (len(x) - N_{fft}) / H \rceil + 1$
\State $X_{stft} \gets \text{zeros}(N_{fft}/2 + 1, N_t)$ \Comment{One-sided}
\State Precompute Gaussian window: $w[m] \gets e^{-m^2/(2\sigma^2)}$
\For{$n \gets 0$ to $N_t - 1$}
    \State Extrage fereastră: $x_n \gets x[nH : nH + N_{fft}]$
    \State Aplică fereastră: $x_w \gets x_n \odot w$
    \State Calculează FFT: $X_n \gets \text{fft}(x_w, N_{fft})$
    \State Stochează one-sided: $X_{stft}[:, n] \gets X_n[0 : N_{fft}/2 + 1]$
\EndFor
\State Normalize: $X_{stft} \gets X_{stft} / \sum_m w[m]^2$
\State \Return $X_{stft}$
\end{algorithmic}
\end{algorithm}

\subsubsection{Pasul 2: Detecția CFAR 2D}

\begin{algorithm}[H]
\caption{Detecția CFAR 2D (GOCA)}
\begin{algorithmic}[1]
\Require Matricea STFT $X_{stft}$, $P_f=0.4$, $N_G=16$, $N_T=16$
\Ensure Mască de detecție binară $H \in \{0,1\}^{N_f \times N_t}$
\State $H \gets \text{zeros}(N_f, N_t)$
\State $N_f \gets $ rows($X_{stft}$), $N_t \gets $ cols($X_{stft}$)
\For{$k \gets N_G + N_T$ to $N_f - N_G - N_T - 1$}
    \For{$n \gets N_G + N_T$ to $N_t - N_G - N_T - 1$}
        \State Extrage Training Cells: regiunea în jurul $(k,n)$
        \State $\mathcal{N}_{local} \gets \frac{1}{4N_G N_T} \sum_{(i,j) \in TC} |X_{stft}(i,j)|^2$
        \State $\lambda \gets P_f \cdot \mathcal{N}_{local}$
        \If{$|X_{stft}(k,n)|^2 > \lambda$}
            \State $H(k,n) \gets 1$
        \EndIf
    \EndFor
\EndFor
\State \Return $H$
\end{algorithmic}
\end{algorithm}

\subsubsection{Pasul 3: Clustering DBSCAN}

\begin{algorithm}[H]
\caption{Clustering DBSCAN în Plan Timp-Frecvență}
\begin{algorithmic}[1]
\Require Puncte detectate $\{(f_i, t_i)\}_{i=1}^{N_p}$, $\varepsilon=4$, minSamples$=5$
\Ensure Etichetele clusterelor $\text{labels} \in \mathbb{Z}$
\State $\text{labels} \gets -1 \cdot \text{ones}(N_p)$ \Comment{-1 = zgomot}
\State $C \gets 0$ \Comment{Indexul clusterului curent}
\For{$i \gets 1$ to $N_p$}
    \If{labels$[i] \neq$ unvisited}
        \State Continue
    \EndIf
    \State $N \gets \text{RangeQuery}(i, \varepsilon)$ \Comment{Vecini în rază}
    \If{$|N| < $ minSamples}
        \State labels$[i] \gets -1$ \Comment{Zgomot}
    \Else
        \State $C \gets C + 1$
        \State \textbf{ExpandCluster}$(i, C, N, \varepsilon, \text{minSamples})$
    \EndIf
\EndFor
\State \Return labels
\end{algorithmic}
\end{algorithm}

\subsubsection{Pasul 4: Dilatare Geodezică}

\begin{algorithm}[H]
\caption{Dilatare Geodezică pe Mască}
\begin{algorithmic}[1]
\Require Mască binară $H$ (din CFAR), iterații $n_{iter}=3$
\Ensure Mască dilatată $H_{dil}$
\State $H_{dil} \gets H$
\State Kernel $\gets$ cruce $3 \times 3$ binar
\For{$i \gets 1$ to $n_{iter}$}
    \State $H_{new} \gets \text{zeros}(H_{dil}.shape)$
    \For{$k \gets 1$ to rows($H_{dil}$) $-2$}
        \For{$n \gets 1$ to cols($H_{dil}$) $-2$}
            \State $H_{new}(k,n) = \max(H_{dil}(k-1,n), H_{dil}(k,n),$ 
            \State \hspace{3cm} $H_{dil}(k+1,n), H_{dil}(k,n-1), H_{dil}(k,n+1))$
        \EndFor
    \EndFor
    \State $H_{dil} \gets H_{new}$
\EndFor
\State \Return $H_{dil}$
\end{algorithmic}
\end{algorithm}

\subsubsection{Pasul 5: iSTFT cu Pragul de Putere}

\begin{algorithm}[H]
\caption{Reconstrucția Inversă (iSTFT)}
\begin{algorithmic}[1]
\Require STFT original $X_{stft}$, mască dilatată $H_{dil}$, fereastră $w$, hop $H=256$
\Ensure Semnalul reconstruit $\hat{x}(n)$
\State $X_{masked} \gets X_{stft} \odot H_{dil}$ \Comment{Aplicare mască element-wise}
\State $N_t \gets $ cols($X_{masked}$)
\State $M \gets N_{fft}$ \Comment{Lungimea semnalului reconstruit}
\State $\hat{x} \gets \text{zeros}(M)$
\For{$n \gets 0$ to $N_t - 1$}
    \State Calculează iFFT: $x_n \gets \text{ifft}(X_{masked}[:, n], N_{fft})$
    \State Aplică fereastră: $x_w \gets \text{real}(x_n) \odot w$
    \State Adună cu overlap-add: $\hat{x}[nH : nH + N_{fft}] \mathrel{+}= x_w$
\EndFor
\State Normalize prin fereastră: $\hat{x} \gets \hat{x} / (\sum_m w[m]^2)$
\State \Return $\hat{x}$
\end{algorithmic}
\end{algorithm}

\section{Date și Surse de Validare}

\subsection{Baza de Date IPIX - Radar Maritim}

O componentă esențială a acestui proiect este utilizarea datelor reale din baza IPIX (Intelligent PIxel processing for X-band radar), furnizată de McMaster University, Canada. Aceste date provin de la un radar coherent polarimetric în bandă X, instalat pentru monitorizarea activității maritime.

\subsubsection{Caracteristici Tehnice IPIX}

Radarul IPIX este un sistem de înaltă performanță specializat în detectarea obiectelor pe suprafața mării în prezența zgomotului de clutter (sea-clutter):

\begin{itemize}
    \item \textbf{Frecvență RF}: 9.39 GHz (bandă X) - optimă pentru detectarea obiectelor mici
    \item \textbf{PRF (Pulse Repetition Frequency)}: 1000 Hz - permite detectarea vitezelor Doppler
    \item \textbf{Lungimea pulsului}: 200 ns - rezoluție spațială ridicată
    \item \textbf{Lățimea fasciculului}: 0.9 grade - precizie angulară excelentă
    \item \textbf{Format date}: Complex I/Q (In-phase + Quadrature)
\end{itemize}

\subsubsection{Ce Sunt Datele I/Q Complexe?}

Spre deosebire de semnalele audio sau sintetice simple (reale), datele radar sunt \textbf{complexe}: fiecare eșantion este de forma $x(t) = I(t) + j \cdot Q(t)$.

\begin{itemize}
    \item \textbf{Componenta I (In-phase)}: Reprezintă proiecția semnalului pe axa cosinus
    \item \textbf{Componenta Q (Quadrature)}: Proiecția pe axa sinus (deplasată cu 90°)
    \item \textbf{Magnitudine}: $|x(t)| = \sqrt{I^2 + Q^2}$ - intensitatea ecoului
    \item \textbf{Fază}: $\phi(t) = \arctan(Q/I)$ - informația Doppler
\end{itemize}

Reprezentarea I/Q permite \textbf{detectarea frecvențelor Doppler pozitive și negative}, esențială pentru distingerea între:
\begin{itemize}
    \item Ținte care se apropie (frecvență Doppler pozitivă)
    \item Ținte care se îndepărtează (frecvență Doppler negativă)
    \item Clutter static (frecvență Doppler ≈ 0 Hz)
\end{itemize}

\subsubsection{Conținutul Bazei de Date}

Pentru acest proiect, am folosit două fișiere principale din baza IPIX:

\begin{table}[H]
\centering
\caption{Fișierele IPIX Folosite în Experimente}
\begin{tabular}{lccl}
\toprule
\textbf{Fișier} & \textbf{Stare Mare} & \textbf{Eșantioane} & \textbf{Caracteristici} \\
\midrule
hi.npy & Mare înaltă & 131,072 & Clutter intens, valuri mari \\
lo.npy & Mare joasă & 131,072 & Clutter moderat, condiții calme \\
\bottomrule
\end{tabular}
\end{table}

Cele două seturi de date corespund unor \textbf{condiții meteorologice diferite}:

\begin{itemize}
    \item \textbf{High Sea State (hi.npy)}: Înregistrări în condiții de mare agitată, cu valuri mari și vânt puternic. Zgomotul de clutter este intens, iar detecția țintelor devine mai dificilă. Dynamic range: ~11 dB.
    \item \textbf{Low Sea State (lo.npy)}: Condiții calme, cu clutter mai redus. Țintele sunt mai ușor de detectat, dar algoritmul trebuie să fie robust și în condiții extreme. Dynamic range: ~9 dB.
\end{itemize}

\subsubsection{Cum Citim Datele Complexe în Python?}

În implementarea noastră, citirea și procesarea datelor I/Q se face simplu cu NumPy:

\begin{lstlisting}[language=Python]
import numpy as np

# Citim datele complexe (I + jQ)
ipix_data = np.load('data/ipix_radar/hi.npy')

# ipix_data.dtype = complex128 (numere complexe)
# ipix_data.shape = (131072,) - vector 1D

# Extragem componentele
I = np.real(ipix_data)  # Componenta In-phase
Q = np.imag(ipix_data)  # Componenta Quadrature

# Calculam magnitudinea si faza
magnitude = np.abs(ipix_data)
phase = np.angle(ipix_data)

# Puterea semnalului
power = magnitude ** 2
\end{lstlisting}

\textbf{Important}: Pentru semnale complexe, STFT se calculează cu \texttt{return\_onesided=False}, astfel încât spectrul să includă frecvențe negative (necesare pentru Doppler).

\section{Rezultate Experimentale}

\subsection{Experimente pe Semnale Sintetice}

S-au efectuat 100 rulări Monte Carlo pentru fiecare nivel de SNR (5, 10, 15, 20, 25, 30 dB). Semnalul sintetic este un chirp nonliniar conform ecuației 14 din articol.

\begin{table}[H]
\centering
\caption{Rezultate CFAR-STFT pe Chirp Nonliniar Sintetic - 100 rulări MC}
\label{tab:results_synthetic}
\begin{tabular}{ccccc}
\toprule
\textbf{SNR [dB]} & \textbf{RQF\_mean [dB]} & \textbf{RQF\_std [dB]} & \textbf{P\_detection [\%]} & \textbf{N\_runs} \\
\midrule
5 & 7.28 & 0.47 & 100.0 & 100 \\
10 & 16.81 & 0.60 & 100.0 & 100 \\
15 & 22.95 & 0.56 & 100.0 & 100 \\
20 & 26.40 & 0.51 & 100.0 & 100 \\
25 & 28.43 & 0.39 & 100.0 & 100 \\
30 & 29.17 & 0.25 & 100.0 & 100 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Observații și Analiză}:

\begin{itemize}
    \item RQF crește monoton cu SNR, conform așteptărilor teoretice
    \item Pe acest semnal sintetic ideal (chirp izolat), algoritmul detectează componenta în toate rulările
    \item La SNR=30dB, RQF $\approx$ 29.17 dB (vs ~35 dB în paper)
    \item Diferența de ~6 dB poate fi datorată:
    \begin{enumerate}
        \item Detailurilor de implementare a ferestrei
        \item Parametrilor CFAR adaptați pentru minimizare zgomot
        \item Detaliilor de normalizare a iSTFT
    \end{enumerate}
    \item Variația (std) se reduce cu SNR - comportament așteptat
    \item Rezultatele sunt reproducibile pe 100 rulări
\end{itemize}

\subsection{Experimente pe Date Reale IPIX}

Am rulat algoritmul CFAR-STFT pe multiple segmente din baza de date IPIX pentru a valida performanța pe date maritime reale. Spre deosebire de semnalele sintetice (unde știm exact forma semnalului), datele IPIX sunt \textbf{zgomotoase și imprevizibile}, conținând:

\begin{itemize}
    \item Ecourile de la suprafața mării (sea-clutter) - predominant
    \item Posibile ținte în mișcare (ambarcațiuni, obiecte plutitoare)
    \item Zgomot termic și interferențe atmosferice
    \item Efecte Doppler din mișcarea valurilor
\end{itemize}

Am testat \textbf{8 segmente} din ambele fișiere (hi.npy și lo.npy), variind lungimea segmentelor între 8192 și 16384 eșantioane. Pentru fiecare segment:

\begin{enumerate}
    \item Am rulat CFAR-STFT cu parametrii identici din paper
    \item Am numărat componente detectate și clustere DBSCAN
    \item Am calculat dynamic range pentru a evalua calitatea semnalului
    \item Am extras vitezele Doppler estimate din centroizii clusterelor
\end{enumerate}

\subsubsection{Ce Sunt Sea-Clutter-urile? Interpretarea Spectrogramelor IPIX}

Înainte de a prezenta rezultatele, este esențial să înțelegem \textbf{ce vedem de fapt} în spectrogramele IPIX. Spre deosebire de semnalele sintetice clare, datele radar maritime conțin fenomene fizice complexe.

\textbf{De ce arată spectrograma IPIX "ciudat"?}

Datele IPIX sunt \textbf{complexe I/Q}, deci spectrograma este \textbf{two-sided} (frecvențe negative și pozitive):

\begin{itemize}
    \item \textbf{Linia roșie groasă pe mijloc}: Frecvența 0 Hz (DC) - ecourile statice de la suprafața mării
    \item \textbf{Galben/Verde în jurul DC}: Sea-clutter-ul activ (valuri, spumă, mișcare)
    \item \textbf{Albastru lateral}: Zgomot termic uniform și slab
    \item \textbf{Aspect "dotted"}: Energia este concentrată în ridges (creste) timp-frecvență, nu uniformă
\end{itemize}

\textbf{Ce este sea-clutter-ul?}

Sea-clutter (zgomotul maritim) reprezintă \textbf{ecourile radar de la suprafața mării}:

\begin{itemize}
    \item Reflexii de la valuri, spumă, picături de apă
    \item Concentrat în jurul frecvenței 0 Hz (Doppler mic - mișcare lentă)
    \item Energie în aproximativ 90-95\% din cazuri în intervalul $[-50, +50]$ Hz
    \item Are structură neuniformă - unele zone sunt mai intense (ridges)
    \item Țintele reale (nave, obiecte) apar departe de DC ($\pm 100-400$ Hz)
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{../results/ipix_figures/ipix_seaclutter_explanation.png}
\caption{Explicație vizuală: ce sunt sea-clutter-urile în datele IPIX? Figura arată spectrograma completă (two-sided), zoom pe regiunea de clutter în jurul DC (frecvența 0 Hz), și distribuția energiei pe frecvențe. Observați că majoritatea energiei (>90\%) este concentrată în $\pm 50$ Hz în jurul DC.}
\label{fig:seaclutter_explain}
\end{figure}

\textbf{De ce detecțiile par "puncte random"?}

Nu sunt random! CFAR detectează \textbf{ridges (creste) de energie} în spectrogramă:

\begin{itemize}
    \item Sea-clutter-ul nu este uniform - are regiuni mai intense
    \item Algoritmul detectează aceste regiuni ca "componente"
    \item Fiecare componentă = un ridge urmărit în timp-frecvență
    \item Aspect dotted = rezoluția STFT (512 bins) + hop (256) creează grilă discretă
\end{itemize}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{../results/ipix_figures/ipix_clutter_better_detection.png}
\caption{Detecție CFAR optimizată pentru sea-clutter. (a) Spectrogramă completă cu linia DC marcată, (b) Detecții CFAR (puncte portocalii), (c) 19 clustere DBSCAN identificate, (d) Zoom pe regiunea de clutter (±50 Hz) arătând detecțiile concentrate în jurul DC. Parametri: N\_G=4, N\_T=8, P\_f=0.02.}
\label{fig:clutter_detection}
\end{figure}

\subsubsection{De Ce CFAR Nu Detectează "Toată Zona Albă"?}

O întrebare legitimă când privim rezultatele: \textit{"De ce detectează doar puncte răzlețe, nu toată regiunea cu energie mare?"}. Răspunsul ține de natura \textbf{locală adaptivă} a CFAR-ului:

\begin{itemize}
    \item \textbf{Prag Global}: Un algoritm simplist ar seta un prag fix (ex: "detectează tot ce e peste -20 dB"). Așa ar detecta \textit{toată zona albă} --- dar ar detecta și zgomot puternic, generând mii de false alarms!
    
    \item \textbf{CFAR Adaptiv Local}: Compară fiecare pixel cu \textit{vecinii săi} (training cells). Dacă pixelul e "mult mai puternic decât media vecinilor locali" $\rightarrow$ detectat. Altfel $\rightarrow$ ignorat.
\end{itemize}

\textbf{Consecința}: În interiorul unei zone uniforme de energie mare (sea-clutter), toți pixelii au \textit{vecini la fel de puternici} $\rightarrow$ CFAR nu îi detectează, pentru că nu sunt "outliers" față de contextul local! CFAR detectează doar:
\begin{itemize}
    \item \textbf{Marginile} (edges) unde energia crește brusc
    \item \textbf{Ridge-urile} (creste de energie) care depășesc clutter-ul înconjurător
    \item \textbf{Ținte reale} care emergă din zgomot/clutter
\end{itemize}

De aceea pare că ia "puncte random" --- în realitate, ia exact punctele care reprezintă \textit{tranziții de putere}! Figura \ref{fig:cfar_local_vs_global} compară cele două abordări:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.98\textwidth]{../results/ipix_figures/cfar_local_vs_global.png}
    \caption{Comparație între prag global (detectează 1980 puncte = toată zona albă) și CFAR adaptiv local (detectează 55 puncte = doar ridge-uri și margini). CFAR se adaptează la nivelul local de zgomot, evitând false alarms în zone de clutter uniform. Regiunea zoom arată cum CFAR compară Cell Under Test (CUT) cu vecinii săi (training cells galbene, guard cells roșii). Profilul temporal ilustrează de ce CFAR nu detectează în interiorul zonei de energie constantă --- toți pixelii au putere similară cu vecinii!}
    \label{fig:cfar_local_vs_global}
\end{figure}

Aceasta este \textit{puterea} CFAR-ului: reduce dramatic false alarm rate-ul adaptându-se la zgomot. Prețul plătit: nu mai detectăm "zone întregi", ci doar punctele care chiar conțin informație nouă (schimbări abrupte în spectrogramă).

\subsubsection{Figuri Reprezentative pe Date IPIX}

În figurile următoare prezentăm cele mai bune 4 segmente detectate, ordonate după calitatea detecției (număr componente × dynamic range):

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{../results/ipix_figures/ipix_hi_lung_începind_5k_detection.png}
\caption{Detecție IPIX pe High Sea State - segment lung (16384 eșantioane). Algoritmul a detectat 27 componente distincte în condiții de mare agitată. Spectrograma arată clutter maritim complex cu ridge-uri clare de energie. Parametri ajustați: N\_G=6, N\_T=10, P\_f=0.05. Dynamic range: 11.4 dB.}
\label{fig:ipix_hi_long}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{../results/ipix_figures/ipix_lo_lung_începind_5k_detection.png}
\caption{Detecție IPIX pe Low Sea State - segment lung (16384 eșantioane). Algoritmul a identificat 25 componente coerente. Clusterele DBSCAN separă clar diferite regiuni de energie din spectrogramă. Dynamic range: 8.9 dB.}
\label{fig:ipix_lo_long}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{../results/ipix_figures/ipix_hi_mijloc_detection.png}
\caption{Detecție IPIX pe High Sea State - segment scurt. În condiții de mare agitată, algoritmul a identificat 1 componentă principală. Observăm detecții CFAR concentrate pe ridge-uri clare în spectrogramă. Dynamic range: 11.2 dB.}
\label{fig:ipix_hi_mid}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=0.95\textwidth]{../results/ipix_figures/ipix_lo_început_detection.png}
\caption{Detecție IPIX pe Low Sea State - segment scurt. 1 cluster detectat cu energie concentrată. Algoritmul distinge clar între semnal și zgomot de clutter.}
\label{fig:ipix_lo_start}
\end{figure}

\begin{table}[H]
\centering
\caption{Rezultate CFAR-STFT pe Date IPIX Maritime}
\label{tab:ipix_results}
\begin{tabular}{lcccc}
\toprule
\textbf{Segment} & \textbf{Stare Mare} & \textbf{Eșantioane} & \textbf{Componente} & \textbf{DR [dB]} \\
\midrule
hi\_lung\_5k & Înaltă & 16384 & 27 & 11.4 \\
lo\_lung\_5k & Joasă & 16384 & 25 & 8.9 \\
hi\_mijloc & Înaltă & 8192 & 1 & 11.2 \\
lo\_început & Joasă & 8192 & 1 & 9.4 \\
\midrule
\textbf{Medie} & -- & -- & \textbf{13.5} & \textbf{10.2} \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Parametri CFAR ajustați pentru IPIX}:

Datele IPIX necesită parametri diferiți față de semnalele sintetice datorită naturii clutter-ului maritim:

\begin{itemize}
    \item $N_G = 6$ (față de 16 pentru sintetic) - guard cells mai mici
    \item $N_T = 10$ (față de 16 pentru sintetic) - training cells reduse
    \item $P_f = 0.05$ (față de 0.4 pentru sintetic) - prag mult mai strict
    \item $\varepsilon_{DBSCAN} = 3.0$ - clustering moderat
    \item minSamples = 3 - clusters mai permisive pentru date reale
\end{itemize}

\textbf{Observații pe Date IPIX}:

\begin{itemize}
    \item Algoritmul detectează cu succes clustere coerente în sea-clutter complex
    \item Segmentele lungi (16k eșantioane) permit detectarea a 25-27 componente
    \item Segmentele scurte (8k eșantioane) detectează 0-1 componente principale
    \item High Sea State (mare agitată) are dynamic range mai mare (11.2-11.4 dB)
    \item Low Sea State (mare calmă) are dynamic range mai mic (8.9-9.4 dB)
    \item CFAR adaptiv funcționează bine cu parametri ajustați pentru clutter maritim
    \item Vizualizarea cu colormap \texttt{jet} și scalare percentilă evidențiază ridge-urile
\end{itemize}

\subsection{Analiza Timpului de Execuție}

\begin{itemize}
    \item STFT cu FFT optimizat: $\sim 10$ ms pentru 131,072 eșantioane
    \item CFAR 2D cu convoluție vectorizată: $\sim 50$ ms (versiune optimizată)
    \item DBSCAN cu spatial indexing: $\sim 5$ ms
    \item iSTFT overlap-add: $\sim 8$ ms
    \item Dilatare geodezică: $\sim 2$ ms
    \item \textbf{Total pe segment}: $\sim 75$ ms (13 FPS - timp real pentru multe aplicații)
\end{itemize}

\section{Detalii de Implementare}

\subsection{Povestea Implementării: De la Teorie la Cod}

În această secțiune, prezentăm \textbf{modul real de lucru}, nu doar referințe tehnice. Am citit paper-ul lui Abratkiewicz și am implementat pas cu pas fiecare componentă, debugând și optimizând până la rezultate corecte.

\subsubsection{Pasul 1: STFT cu Fereastră Gaussiană}

Primul pas a fost calculul STFT. Am folosit \texttt{scipy.signal.stft}, dar cu atenție la detalii:

\begin{lstlisting}[language=Python]
# src/cfar_stft_detector.py, liniile ~420-480
def compute_stft(self, signal_data):
    # Cream fereastra Gaussiana (sigma=8 bins)
    window = signal.windows.gaussian(self.window_size, std=8)
    
    # Verificam daca semnalul e complex (I/Q radar)
    is_complex = np.iscomplexobj(signal_data)
    
    if is_complex:
        # Two-sided STFT pentru radar (include frecvente negative)
        freqs, times, Zxx = signal.stft(
            signal_data,
            fs=self.fs,
            window=window,
            nperseg=self.window_size,  # 512
            noverlap=self.window_size - self.hop_size,  # 256
            return_onesided=False  # IMPORTANT pentru Doppler!
        )
        # Reordonam cu fftshift pentru a centra frecventele
        Zxx = np.fft.fftshift(Zxx, axes=0)
        freqs = np.fft.fftshift(freqs)
    else:
        # One-sided pentru semnale reale
        freqs, times, Zxx = signal.stft(
            ..., return_onesided=True
        )
\end{lstlisting}

\textbf{Decizie de design}: Am suportat atât semnale reale (audio, sintetic) cât și complexe (radar I/Q). Paper-ul nu specifică acest detaliu, dar era necesar pentru IPIX.

\subsubsection{Pasul 2: GOCA-CFAR 2D}

Am implementat \textbf{două versiuni} ale CFAR:

\textbf{Versiunea 1: Nested-loop (fidelă paper-ului)}

\begin{lstlisting}[language=Python]
# src/cfar_stft_detector.py, liniile ~88-170
def detect(self, stft_magnitude):
    for k in range(total_v, n_freq - total_v):
        for m in range(total_h, n_time - total_h):
            # Extrage 4 sub-regiuni (up, down, left, right)
            region_up = stft_magnitude[
                k - total_v : k - self.N_G_v,
                m - total_h : m + total_h + 1
            ]
            # ... similar pentru down, left, right
            
            # GOCA: ia MAXIMUL estimarilor
            noise_estimate = max([mean(r) for r in regions])
            threshold = self.R * noise_estimate
            
            if cut_value >= threshold:
                detection_map[k, m] = True
\end{lstlisting}

Această versiune este \textbf{lentă} (nested loops pe toată grila TF), dar \textbf{100\% fidelă} algoritmului GOCA din paper.

\textbf{Versiunea 2: Vectorizată cu Convoluție (optimizată)}

\begin{lstlisting}[language=Python]
# src/cfar_stft_detector.py, liniile ~172-220
def detect_vectorized(self, stft_magnitude):
    # Cream kernel pentru training cells
    kernel = np.ones((kernel_v, kernel_h))
    # Setam guard + CUT la 0
    kernel[guard_start:guard_end, :] = 0
    kernel[:, guard_start:guard_end] = 0
    
    # Normalizăm
    kernel = kernel / np.sum(kernel)
    
    # Convolutie 2D pentru media locala (RAPID!)
    noise_estimate = ndimage.convolve(
        stft_magnitude, kernel, mode='constant'
    )
    
    # Detectie vectorizată
    threshold = self.R * noise_estimate
    detection_map = stft_magnitude >= threshold
\end{lstlisting}

Această versiune este \textbf{~10-20x mai rapidă}, dar implementează practic un CA-CFAR clasic (media pe toate celulele), nu GOCA explicit. Totuși, diferența în rezultate este minimă pentru majoritatea cazurilor.

\textbf{Am rulat experimente cu ambele versiuni}: rezultatele sunt similare (diferență < 2\% în RQF), dar versiunea vectorizată reduce timpul de la ~50ms la ~5ms per segment.

\subsubsection{Pasul 3: DBSCAN cu Coordonate Fizice}

Paper-ul nu specifică detalii despre DBSCAN, dar am implementat o versiune \textbf{custom adaptată pentru coordonate Hz/secunde}:

\begin{lstlisting}[language=Python]
# src/cfar_stft_detector.py, liniile ~227-340
class DBSCAN:
    def fit(self, points, freqs, times):
        # Convertim index-uri in Hz si secunde
        df = freqs[1] - freqs[0]
        dt = times[1] - times[0]
        
        real_points[:, 0] = freqs[indices] / df  # bins frecventa
        real_points[:, 1] = times[indices] / dt  # bins timp
        
        # Rulam DBSCAN clasic
        for i in range(n_points):
            neighbors = self._region_query(points, i)
            if len(neighbors) >= self.min_samples:
                # Cream cluster si expandam
                ...
\end{lstlisting}

\textbf{De ce coordonate fizice?} Parametrul \texttt{eps} devine astfel \textbf{interpretabil}: eps=4 înseamnă "4 bins distanță", indiferent de sample rate sau dimensiunea FFT.

\subsubsection{Pasul 4: Geodesic Dilation}

Extinderea măștii spre zerourile spectrogramei este esențială pentru a captura toată energia componentei:

\begin{lstlisting}[language=Python]
# src/cfar_stft_detector.py, liniile ~840-890
def _expand_mask_geodesic(self, mask, n_iter=3):
    # Kernel cruce 3x3 (nu pătrat, ca în paper)
    kernel = np.array([[0,1,0], [1,1,1], [0,1,0]])
    
    for iteration in range(n_iter):
        # Dilatare standard
        dilated = ndimage.binary_dilation(mask, kernel)
        
        # CONSTRANGERE: doar unde spectrograma e 'non-zero'
        # (mai mare decat threshold de zgomot)
        dilated = dilated & (~self.zero_map)
        
        mask = dilated
    
    return mask
\end{lstlisting}

\textbf{Decizie critică}: Am folosit \textbf{cruce 3×3} (4-conectivitate), nu pătrat 3×3 (8-conectivitate), pentru a evita extinderea agresivă către regiuni de zgomot.

\subsubsection{Pasul 5: iSTFT cu Overlap-Add}

Reconstrucția semnalului din STFT mascat:

\begin{lstlisting}[language=Python]
# scipy.signal.istft face overlap-add automat
reconstructed = signal.istft(
    Zxx_masked,  # STFT * mask
    fs=self.fs,
    window=window,  # Aceeasi fereastra!
    nperseg=self.window_size,
    noverlap=self.window_size - self.hop_size
)[1]  # Returneaza (times, signal)
\end{lstlisting}

\textbf{Atenție}: Trebuie să folosim \textbf{aceeași fereastră} la STFT și iSTFT pentru a păstra energia.

\subsubsection{Optimizări Făcute în Iterații}

Am rulat algoritmul \textbf{de zeci de ori}, ajustând parametri după fiecare rulare:

\begin{enumerate}
    \item \textbf{Iterația 1}: Rezultate slabe (RQF ~5 dB) - problema: folosisem fereastră Hann în loc de Gaussiană
    \item \textbf{Iterația 2}: Îmbunătățire la RQF ~15 dB - am corectat fereastra
    \item \textbf{Iterația 3-5}: Ajustat $N_G$ și $N_T$ (testat 8, 12, 16, 24) - optim: 16
    \item \textbf{Iterația 6-10}: Calibrat $P_f$ (testat 0.1, 0.2, 0.4, 0.6) - optim: 0.4
    \item \textbf{Iterația 11}: Implementat CFAR vectorizat - viteză crescută 10×
    \item \textbf{Iterația 12-15}: Ajustat DBSCAN eps (testat 2, 3, 4, 5, 8) - optim: 4
    \item \textbf{Rezultat final}: RQF ~29 dB @ SNR=30dB, timp execuție ~75ms
\end{enumerate}

\subsection{Structura Codului}

Implementarea este organizată în module Python:

\subsubsection{src/cfar\_stft\_detector.py (392 linii)}

Fișier principal: \href{https://github.com/dirgnic/Radar_Detection_STFT/blob/main/src/cfar_stft_detector.py}{\texttt{src/cfar\_stft\_detector.py}}

Clase principale:

\begin{itemize}
    \item \textbf{CFAR2D}: Implementare GOCA-CFAR 2D și CA-CFAR vectorizat
        \begin{itemize}
            \item \texttt{detect()}: GOCA-CFAR cu 4 sub-regiuni (robust, algorithmic paper)
            \item \texttt{detect\_vectorized()}: CA-CFAR rapid cu convoluție SciPy
        \end{itemize}
    \item \textbf{DBSCAN}: Clustering în coordonate fizice (Hz, s)
        \begin{itemize}
            \item \texttt{fit()}: segmentare puncte detectate
            \item \texttt{\_region\_query()}: căutare vecini în rază eps
        \end{itemize}
    \item \textbf{CFARSTFTDetector}: Pipeline complet de detecție și reconstrucție
        \begin{itemize}
            \item \texttt{compute\_stft()}: STFT cu fereastră Gaussiană
            \item \texttt{detect\_components()}: pipeline STFT $\rightarrow$ CFAR $\rightarrow$ DBSCAN
            \item \texttt{reconstruct\_component()}: reconstrucție prin iSTFT
            \item \texttt{get\_doppler\_info()}: analiză Doppler
        \end{itemize}
\end{itemize}

\subsubsection{simulations/paper\_replication.py (1087 linii)}

Fișier de validare: \href{https://github.com/dirgnic/Radar_Detection_STFT/blob/main/simulations/paper_replication.py}{\texttt{simulations/paper\_replication.py}}

Funcții principale:

\begin{itemize}
    \item \textbf{run\_paper\_experiment()} (liniile 250-400): 
        \begin{itemize}
            \item 100 rulări Monte Carlo pe signal sintetic
            \item 6 nivele de SNR (5-30 dB)
            \item Stocare rezultate în JSON
        \end{itemize}
    \item \textbf{run\_ipix\_experiment()} (liniile 400-600): Test pe date reale
        \begin{itemize}
            \item 50 segmente din baza IPIX
            \item Analiză Doppler automat
        \end{itemize}
    \item \textbf{compute\_rqf()} (liniile 150-200): Calculul metricii RQF
    \item \textbf{generate\_paper\_signal()}: Generator chirp nonliniar (Eq. 14)
    \item \textbf{add\_awgn()}: Adăugare zgomot Gaussian
\end{itemize}

\subsubsection{scripts/visualize\_detections.py (673 linii)}

Fișier de vizualizare: Diagrame T-F cu detecții CFAR, clustere DBSCAN, mască dilatată.

\subsection{Dependințe Software}

\begin{itemize}
    \item \textbf{NumPy} $\geq$ 1.19 - operații cu matrice
    \item \textbf{SciPy} $\geq$ 1.5 - STFT, convoluție, iFFT
    \item \textbf{matplotlib} $\geq$ 3.3 - vizualizări
    \item (opțional) \textbf{scikit-learn} - DBSCAN
\end{itemize}

\subsection{Parametri Critici și Calibrare}

\begin{table}[H]
\centering
\caption{Parametri Algoritm - Valori Folosite}
\begin{tabular}{lccc}
\toprule
\textbf{Parametru} & \textbf{Valoare} & \textbf{Domeniu} & \textbf{Semnificație} \\
\midrule
$N_{fft}$ & 512 & $[256, 1024]$ & Lungimea FFT \\
$H$ & 256 & $[N_{fft}/4, N_{fft}/2]$ & Hop $=$ 50\% overlap \\
$\sigma_{window}$ & 8 & [4, 16] & Deviere std fereastră \\
$P_f$ & 0.4 & [0.1, 0.9] & Probabilitate falsă alarmă \\
$N_G$ & 16 & [8, 32] & Dimensiune guard cell \\
$N_T$ & 16 & [8, 32] & Dimensiune training cell \\
$\varepsilon_{DBSCAN}$ & 4 & [2, 8] & Rază clustering (Hz/s) \\
minSamples & 5 & [3, 15] & Puncte minime cluster \\
$n_{iter,dil}$ & 3 & [1, 5] & Iterații dilatare \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Contribuția noastră și bibliotecile folosite}

Un obiectiv important al proiectului a fost ca \textbf{să implementăm cât mai mult din logică de la zero}, folosind doar biblioteci numerice de bază. Contribuțiile concrete sunt:

\begin{itemize}
    \item implementare \textbf{CFAR2D} completă (atât variantă nested-loop, cât și variantă vectorizată cu convoluție) fără a folosi cod gata făcut din alte biblioteci radar;
    \item implementare \textbf{DBSCAN} custom, adaptat pentru coordonatele fizice (Hz, s), fără a depinde de implementarea din scikit-learn în pipeline-ul principal;
    \item implementare \textbf{dilatări geodezice} pe măști binare direct cu operații NumPy/SciPy, fără biblioteci de morfologie avansată;
    \item implementare completă a pipeline-ului CFAR-STFT într-o singură clasă (\texttt{CFARSTFTDetector}), astfel încât se poate urmări ușor fluxul de la semnal brut la reconstrucție;
    \item cod de generare a semnalului sintetic (chirp nonliniar) și de adăugare de zgomot (AWGN) scris explicit, fără funcții black-box;
    \item \textbf{suport pentru semnale complexe I/Q} (radar) cu detectarea automată a tipului de date și procesare two-sided STFT pentru frecvențe Doppler negative;
    \item \textbf{algoritm de vectorizare CFAR pentru eficiență} - detaliat mai jos.
\end{itemize}

Bibliotecile externe sunt \textbf{minimaliste}:

\begin{itemize}
    \item \textbf{NumPy} și \textbf{SciPy} pentru operații numerice și FFT/STFT;
    \item \textbf{matplotlib} pentru plot-uri și vizualizări;
    \item \textbf{(opțional) scikit-learn} doar pentru a verifica rezultatele DBSCAN față de o implementare de referință, nu în pipeline-ul principal.
\end{itemize}

Astfel, contribuția noastră este clară: \textbf{algoritmii cheie sunt implementați manual}, iar bibliotecile sunt folosite strict ca unelte numerice de bază, nu ca soluții gata făcute.

\subsubsection{Algoritmul de Vectorizare CFAR - Detalii Tehnice}

Paper-ul propune GOCA-CFAR (Greatest Of Cell Averaging), care împarte regiunea de training în 4 sub-regiuni și ia \textbf{maximul} mediilor acestora ca estimare de zgomot. Această abordare este robustă la clutter heterogen, dar necesită loop-uri nested pe toată grila timp-frecvență.

\textbf{Implementarea clasică (GOCA fidel paper-ului)}:

Pentru fiecare celulă (k, m) din spectrograma de putere:
\begin{enumerate}
    \item Extrage 4 sub-regiuni: SUS, JOS, STÂNGA, DREAPTA
    \item Calculează media fiecăreia: $\mu_{up}, \mu_{down}, \mu_{left}, \mu_{right}$
    \item Estimarea zgomot: $\mathcal{N} = \max(\mu_{up}, \mu_{down}, \mu_{left}, \mu_{right})$
    \item Prag: $T = R \cdot \mathcal{N}$, unde $R = N_T \cdot (P_f^{-1/N_T} - 1)$
    \item Detectie: $H(k,m) = 1$ dacă $S(k,m) > T$
\end{enumerate}

Complexitate: $O(N_f \times N_t \times (N_G + N_T)^2)$ - \textbf{lent pentru grile mari}.

\textbf{Varianta vectorizată (CA-CFAR optimizat)}:

În loc de loop-uri, folosim \textbf{convoluție 2D} cu un kernel binar:

\begin{enumerate}
    \item Creăm kernel $(2(N_G+N_T)+1) \times (2(N_G+N_T)+1)$ cu valori 1
    \item Setăm guard zone + CUT la 0 (zona centrală)
    \item Normalizăm: $K = K / \sum K$ (astfel kernel calculează media)
    \item Convoluție: $\mathcal{N} = S \star K$ (operație vectorizată, optimizată de NumPy)
    \item Detectie: $H = S > R \cdot \mathcal{N}$ (operație element-wise vectorizată)
\end{enumerate}

Complexitate: $O(N_f \times N_t \times \log(N_f \times N_t))$ via FFT - \textbf{mult mai rapid}.

\textbf{Diferența față de GOCA}: Varianta vectorizată calculează media pe \textbf{toate} celulele de training simultan, nu maximul celor 4 sub-regiuni. Echivalent cu CA-CFAR (Cell Averaging) clasic.

\textbf{Rezultate comparative} (pe 100 rulări MC, SNR=30dB):
\begin{itemize}
    \item RQF (GOCA nested-loop): 29.17 $\pm$ 0.25 dB
    \item RQF (CA vectorizat): 29.04 $\pm$ 0.28 dB
    \item Diferență: < 0.5\% - \textbf{neglijabilă în practică}
    \item Timp execuție GOCA: ~50 ms per segment
    \item Timp execuție CA vectorizat: ~5 ms per segment
    \item Speedup: \textbf{10× mai rapid}
\end{itemize}

\textbf{Concluzie}: Pentru aplicații real-time sau procesare batch mare, varianta vectorizată este preferabilă. Pentru validare științifică strictă față de paper, varianta GOCA nested-loop este disponibilă (flag \texttt{use\_vectorized\_cfar=False}).

\section{Concluzii și Perspective}

\subsection{Concluzii Principale}

Implementarea CFAR-STFT demonstrează performanțe excelente:

\begin{enumerate}
    \item \textbf{Acuratețe}: RQF = 29.17 dB @ SNR=30dB, detecție 100\%
    \item \textbf{Robustețe}: Performanță consistentă pe 100 rulări MC
    \item \textbf{Eficiență computațională}: $\sim 75$ ms per segment (13 FPS)
    \item \textbf{Reproducibilitate}: Cod open-source, rezultate verificabile
    \item \textbf{Validare reală}: Funcționează pe date IPIX sea-clutter complexe
\end{enumerate}

\subsection{Perspective de Dezvoltare Viitoare}

\begin{itemize}
    \item \textbf{Accelerare GPU}: Implementare CUDA/OpenCL pentru timp real
    \item \textbf{Optimizare parametri}: CFAR adaptativ pe baza tipului de semnal
    \item \textbf{Sistem real}: Integrare cu radar operațional
    \item \textbf{Multi-țintă}: Tracking și predictie traiectorii
    \item \textbf{Machine learning}: Învățare automată pentru calibrare parametri
\end{itemize}

\subsection{Disponibilitate Cod}

\textbf{Repository GitHub}: \url{https://github.com/dirgnic/Radar_Detection_STFT}

Toate fișierele de cod, date, și rezultate sunt disponibile public pentru reproducibilitate și replicare independentă.

\begin{thebibliography}{99}

\bibitem{abratkiewicz2022}
Abratkiewicz, K. (2022).
\textit{Radar Detection-Inspired Signal Retrieval from the Short-Time Fourier Transform}.
Sensors, 22(16), 5954.
\newline \url{https://doi.org/10.3390/s22165954}

\bibitem{harris1978}
Harris, F.J. (1978).
\textit{On the Use of Windows for Harmonic Analysis with the Discrete Fourier Transform}.
Proceedings of the IEEE, 66(1), 51-83.

\bibitem{ester1996}
Ester, M., Kriegel, H.-P., Sander, J., Xu, X. (1996).
\textit{A Density-Based Algorithm for Discovering Clusters in Large Spatial Databases with Noise}.
In KDD'96: Proceedings, pp. 226-231.

\bibitem{richards2005}
Richards, M. A. (2005).
\textit{Fundamentals of Radar Signal Processing}.
McGraw-Hill Professional.

\end{thebibliography}

\end{document}
